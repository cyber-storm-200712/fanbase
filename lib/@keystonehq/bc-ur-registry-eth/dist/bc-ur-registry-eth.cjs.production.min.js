"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),a=require("uuid"),s=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("ethereumjs-util");const r={ETH_SIGN_REQUEST:new e.RegistryType("eth-sign-request",401),ETH_SIGNATURE:new e.RegistryType("eth-signature",402),ETH_NFT_ITEM:new e.RegistryType("eth-nft-item",403)},{decodeToDataItem:n,RegistryTypes:d}=e.extend;var o,h;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(o||(o={})),(h=exports.DataType||(exports.DataType={}))[h.transaction=1]="transaction",h[h.typedData=2]="typedData",h[h.personalMessage=3]="personalMessage",h[h.typedTransaction=4]="typedTransaction";class c extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_SIGN_REQUEST,this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSourceFingerprint=()=>this.derivationPath.getSourceFingerprint(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[o.requestId]=new e.DataItem(this.requestId,d.UUID.getTag())),this.address&&(t[o.address]=this.address),this.chainId&&(t[o.chainId]=this.chainId),this.origin&&(t[o.origin]=this.origin),t[o.signData]=this.signData,t[o.dataType]=this.dataType;const a=this.derivationPath.toDataItem();return a.setTag(this.derivationPath.getRegistryType().getTag()),t[o.derivationPath]=a,new e.DataItem(t)},this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin}static constructETHRequest(t,s,i,r,n,d,o,h){const g=i.replace(/[m|M]\//,"").split("/"),u=new e.CryptoKeypath(g.map(t=>{const a=parseInt(t.replace("'",""));let s=!1;return t.endsWith("'")&&(s=!0),new e.PathComponent({index:a,hardened:s})}),Buffer.from(r,"hex"));return new c({requestId:n?Buffer.from(a.parse(n)):void 0,signData:t,dataType:s,derivationPath:u,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}c.fromDataItem=t=>{const a=t.getData(),s=a[o.signData],i=a[o.dataType],r=e.CryptoKeypath.fromDataItem(a[o.derivationPath]),n=a[o.chainId]?a[o.chainId]:void 0,d=a[o.address]?a[o.address]:void 0,h=a[o.requestId]?a[o.requestId].getData():void 0;return new c({requestId:h,signData:s,dataType:i,chainId:n,derivationPath:r,address:d,origin:a[o.origin]?a[o.origin]:void 0})},c.fromCBOR=t=>{const e=n(t);return c.fromDataItem(e)};const{RegistryTypes:g,decodeToDataItem:u}=e.extend;var m;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature",t[t.origin=3]="origin"}(m||(m={}));class I extends e.RegistryItem{constructor(t,a,s){super(),this.getRegistryType=()=>r.ETH_SIGNATURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};return this.requestId&&(t[m.requestId]=new e.DataItem(this.requestId,g.UUID.getTag())),this.origin&&(t[m.origin]=this.origin),t[m.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=a,this.origin=s}}I.fromDataItem=t=>{const e=t.getData(),a=e[m.signature],s=e[m.requestId]?e[m.requestId].getData():void 0;return new I(a,s,e[m.origin])},I.fromCBOR=t=>{const e=u(t);return I.fromDataItem(e)};const{decodeToDataItem:p}=e.extend;var D;!function(t){t[t.chainId=1]="chainId",t[t.contractAddress=2]="contractAddress",t[t.contractName=3]="contractName",t[t.name=4]="name",t[t.mediaData=5]="mediaData"}(D||(D={}));class T extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>r.ETH_NFT_ITEM,this.getChainId=()=>this.chainId,this.getName=()=>this.name,this.getmediaData=()=>this.mediaData,this.getContractAddress=()=>this.contractAddress,this.getContractName=()=>this.contractName,this.toDataItem=()=>{const t={};return t[D.chainId]=this.chainId,t[D.name]=this.name,t[D.contractAddress]=this.contractAddress,t[D.contractName]=this.contractName,t[D.mediaData]=this.mediaData,new e.DataItem(t)},this.chainId=t.chainId,this.name=t.name,this.contractAddress=t.contractAddress,this.contractName=t.contractName,this.mediaData=t.mediaData}static constructETHNFTItem(t,e,a,s,i){return new T({chainId:t,contractAddress:e,contractName:a,mediaData:i,name:s})}}T.fromDataItem=t=>{const e=t.getData();return new T({chainId:e[D.chainId],name:e[D.name],contractAddress:e[D.contractAddress],contractName:e[D.contractName],mediaData:e[D.mediaData]})},T.fromCBOR=t=>{const e=p(t);return T.fromDataItem(e)};const y=(t,e)=>{const a=s.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(a.publicKey,!0).toString("hex");return i.toChecksumAddress(r)};e.patchTags(Object.values(r).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHNFTItem=T,exports.ETHSignature=I,exports.EthSignRequest=c,exports.findHDPathFromAddress=(t,e,a,s)=>{for(let i=0;i<a;i++){const a=y(e,"M/0/"+i);if(t.toLowerCase()==a.toLowerCase())return`${s}/0/${i}`}return null},exports.generateAddressFromXpub=y;
//# sourceMappingURL=bc-ur-registry-eth.cjs.production.min.js.map
