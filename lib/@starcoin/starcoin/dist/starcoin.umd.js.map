{
  "version": 3,
  "file": "starcoin.umd.js",
  "sources": [
    "../src/types/index.ts",
    "../src/lib/runtime/serde/binaryDeserializer.ts",
    "../src/lib/runtime/bcs/bcsDeserializer.ts",
    "../src/lib/runtime/serde/binarySerializer.ts",
    "../src/lib/runtime/bcs/bcsSerializer.ts",
    "../src/utils/helper.ts",
    "../src/lib/runtime/starcoin_types/index.ts",
    "../src/crypto_hash/index.ts",
    "../src/utils/hex.ts",
    "../src/encoding/index.ts",
    "../src/utils/abi.ts",
    "../src/utils/account.ts",
    "../src/utils/errors.ts",
    "../src/utils/parser.ts",
    "../src/version.ts",
    "../src/utils/properties.ts",
    "../src/utils/signed-message.ts",
    "../src/networks/index.ts",
    "../src/abstract-provider/index.ts",
    "../src/providers/formatter.ts",
    "../src/providers/base-provider.ts",
    "../src/abstract-signer/index.ts",
    "../src/providers/jsonrpc-provider.ts",
    "../src/utils/tx.ts",
    "../src/utils/multi-sign.ts",
    "../src/providers/web3-provider.ts",
    "../src/providers/websocket-provider.ts",
    "../src/lib/runtime/onchain_events/index.ts",
    "../src/onchain_events/index.ts"
  ],
  "sourcesContent": [
    "import { BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike } from \"@ethersproject/bytes\";\nimport { uint128, uint64, uint8 } from '../lib/runtime/serde';\n\nexport type Identifier = string;\nexport type AccountAddress = string;\nexport type HashValue = string;\nexport type U8 = number;\nexport type U16 = number;\nexport type U64 = number | BigInt;\nexport type U128 = number | BigInt;\nexport type U256 = string;\nexport type I64 = number | BigInt;\nexport type BlockNumber = number;\nexport type AuthenticationKey = string;\nexport type Ed25519PublicKey = string;\nexport type Ed25519PrivateKey = string;\nexport type Ed25519Signature = string;\nexport type MultiEd25519PublicKey = string;\nexport type MultiEd25519Signature = string;\nexport type EventKey = string;\nexport type HexString = string;\n\nexport const accountType = {\n  SINGLE: 0,\n  MULTI: 1,\n}\n\nexport interface StructTag {\n  address: string;\n  module: string;\n  name: string;\n  // eslint-disable-next-line no-use-before-define\n  type_params?: TypeTag[];\n}\n\nexport type TypeTag =\n  | 'Bool'\n  | 'U8'\n  | 'U64'\n  | 'U128'\n  | 'Address'\n  | 'Signer'\n  | { Vector: TypeTag }\n  | { Struct: StructTag };\n\nexport function formatStructTag(structTag: StructTag): string {\n  let s = `${ structTag.address }::${ structTag.module }::${ structTag.name }`;\n\n  if (structTag.type_params && structTag.type_params.length > 0) {\n    s = s.concat('<');\n    s = s.concat(formatTypeTag(structTag.type_params[0]));\n    for (let t of structTag.type_params.slice(1)) {\n      s = s.concat(',').concat(formatTypeTag(t));\n    }\n    s = s.concat('>');\n  }\n  return s;\n}\n\nexport function formatTypeTag(typeTag: TypeTag): string {\n  if (typeof typeTag === 'string') {\n    return typeTag.toLowerCase();\n  }\n  if (typeof typeTag === 'object') {\n    // @ts-ignore\n    if (typeTag.Vector !== undefined) {\n      // @ts-ignore\n      let subTypeTag: TypeTag = typeTag.Vector;\n      return `vector<${ formatTypeTag(subTypeTag) }>`;\n    }\n\n    // @ts-ignore\n    if (typeTag.Struct !== undefined) {\n      // @ts-ignore\n      let subTypeTag: StructTag = typeTag.Struct;\n      return formatStructTag(subTypeTag);\n    }\n  }\n}\n\nexport interface ChainId {\n  id: U8;\n}\n\ninterface Script {\n  code: HexString;\n  ty_args: TypeTag[];\n  // eslint-disable-next-line no-use-before-define\n  args: HexString[];\n}\n\ninterface ScriptFunction {\n  func: FunctionId;\n  ty_args: TypeTag[];\n  // eslint-disable-next-line no-use-before-define\n  args: HexString[];\n}\n\ninterface Module {\n  code: HexString;\n}\n\ninterface Package {\n  package_address: AccountAddress;\n  modules: Module[];\n  init_script?: ScriptFunction;\n}\n\nexport type TransactionPayload =\n  | { Script: Script }\n  | { Package: Package }\n  | { ScriptFunction: ScriptFunction };\n\nexport type SignatureType = 'Ed25519' | 'MultiEd25519';\n\nexport type TransactionAuthenticator =\n  | {\n    Ed25519: {\n      public_key: Ed25519PublicKey;\n      signature: Ed25519Signature;\n    };\n  }\n  | {\n    MultiEd25519: {\n      public_key: MultiEd25519PublicKey;\n      signature: MultiEd25519Signature;\n    };\n  };\n\n// export type TransactionArgument =\n//   | { U8: number }\n//   | { U64: BigInt }\n//   | { U128: BigInt }\n//   | { Address: AccountAddress }\n//   | { U8Vector: Uint8Array }\n//   | { Bool: boolean };\n\nexport interface AnnotatedMoveStruct {\n  type_: string;\n  // eslint-disable-next-line no-use-before-define\n  value: [Identifier, AnnotatedMoveValue][];\n}\n\nexport type AnnotatedMoveValue =\n  | { U8: number }\n  | { U64: string }\n  | { U128: string }\n  | { Bool: boolean }\n  | { Address: AccountAddress }\n  | { Bytes: HexString }\n  | { Vector: AnnotatedMoveValue[] }\n  | { Struct: AnnotatedMoveStruct };\n\n// eslint-disable-next-line no-use-before-define\nexport type MoveStruct = { [key in Identifier]: MoveValue };\nexport type MoveValue =\n  | number\n  | bigint\n  | boolean\n  | AccountAddress\n  | HexString\n  | MoveValue[]\n  | MoveStruct;\n\nexport interface EventHandle {\n  count: U64;\n  key: EventKey;\n}\n\nexport interface Epoch {\n  number: U64;\n  // seconds\n  start_time: U64;\n  start_block_number: U64;\n  end_block_number: U64;\n  // seconds\n  block_time_target: U64;\n  reward_per_block: U128;\n  reward_per_uncle_percent: U64;\n  block_difficulty_window: U64;\n  max_uncles_per_block: U64;\n  block_gas_limit: U64;\n  strategy: U8;\n  new_epoch_events: EventHandle;\n}\n\nexport interface EpochData {\n  uncles: U64;\n  total_reward: U128;\n  total_gas: U128;\n}\n\nexport interface EpochInfo {\n  epoch: Epoch;\n  epoch_data: EpochData;\n}\n\nexport interface Event {\n  block_hash?: HashValue;\n  block_number?: BlockNumber;\n  transaction_hash?: HashValue;\n  // txn index in block\n  transaction_index?: U64;\n  data: Uint8Array;\n  type_tags: TypeTag;\n  event_key: EventKey;\n  event_seq_number: U64;\n}\n\nexport interface TypeArgumentABI {\n  /// The name of the argument.\n  name: string;\n}\n\nexport interface ArgumentABI {\n  /// The name of the argument.\n  name: string;\n  /// The expected type.\n  /// In Move scripts, this does contain generics type parameters.\n  type_tag: TypeTag;\n}\n\nexport interface ScriptABI {\n  // The public name of the script.\n  name: string;\n  // Some text comment.\n  doc: string;\n  // The `code` value to set in the `Script` object.\n  code: Uint8Array;\n  // The names of the type arguments.\n  ty_args: TypeArgumentABI[];\n  // The description of regular arguments.\n  args: ArgumentABI[];\n}\n\nexport type AbortLocation =\n  | 'Script'\n  | {\n    Module: {\n      address: AccountAddress;\n      name: Identifier;\n    };\n  };\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const TransactionVMStatus_Executed = 'Executed';\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const TransactionVMStatus_OutOfGas = 'OutOfGas';\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const TransactionVMStatus_MiscellaneousError = 'MiscellaneousError';\nexport type TransactionVMStatus =\n  | 'Executed'\n  | 'OutOfGas'\n  | 'MiscellaneousError'\n  | {\n    MoveAbort: { location: AbortLocation; abort_code: U64 };\n  }\n  | {\n    ExecutionFailure: {\n      location: AbortLocation;\n      function: U16;\n      code_offset: U16;\n    };\n  }\n  | { Discard: { status_code: U64 } };\n\n// Exported Types\n\nexport interface ReceiptIdentifierView {\n  accountAddress: string,\n  authKey: string\n}\n\nexport interface RawUserTransactionView {\n  /// Sender's address.\n  sender: AccountAddress;\n  // Sequence number of this transaction corresponding to sender's account.\n  sequence_number: U64;\n  // The transaction script to execute.\n  payload: HexString;\n\n  // Maximal total gas specified by wallet to spend for this transaction.\n  max_gas_amount: U64;\n  // Maximal price can be paid per gas.\n  gas_unit_price: U64;\n  // The token code for pay transaction gas, Default is STC token code.\n  gas_token_code: string;\n  // Expiration timestamp for this transaction. timestamp is represented\n  // as u64 in seconds from Unix Epoch. If storage is queried and\n  // the time returned is greater than or equal to this time and this\n  // transaction has not been included, you can be certain that it will\n  // never be included.\n  // A transaction that doesn't expire is represented by a very large value like\n  // u64::max_value().\n  expiration_timestamp_secs: U64;\n  chain_id: U8;\n}\n\nexport interface BlockMetadataView {\n  parent_hash: HashValue;\n  timestamp: U64;\n  author: AccountAddress;\n  author_auth_key?: AuthenticationKey;\n  uncles: U64;\n  number: BlockNumber;\n  chain_id: U8;\n  parent_gas_used: U64;\n}\n\nexport interface SignedUserTransactionView {\n  transaction_hash: HashValue;\n  raw_txn: RawUserTransactionView;\n  authenticator: TransactionAuthenticator;\n}\n\nexport interface TransactionRequest {\n  to?: string,\n  from?: string,\n  nonce?: BigNumberish,\n\n  gasLimit?: BigNumberish,\n  gasPrice?: BigNumberish,\n\n  data?: BytesLike,\n  value?: BigNumberish,\n  expiredSecs?: U64;\n  addGasBufferMultiplier?: U8;\n\n  sender?: AccountAddress;\n  sender_public_key?: HexString;\n  sequence_number?: U64;\n\n  script?: {\n    code: string;\n    type_args?: Array<string>;\n    args?: Array<string>;\n  };\n  modules?: Array<HexString>;\n\n  max_gas_amount?: U64;\n  gas_unit_price?: U64;\n  gas_token_code?: string;\n  chain_id?: U8;\n}\n\n/// block hash or block number\nexport type BlockTag = string | number;\nexport type ModuleId = string | { address: AccountAddress; name: Identifier };\nexport type FunctionId =\n  | string\n  | { address: AccountAddress; module: Identifier; functionName: Identifier };\n\nexport interface CallRequest {\n  function_id: FunctionId;\n  type_args?: string[];\n  args?: string[];\n}\n\nexport function formatFunctionId(functionId: FunctionId): string {\n  if (typeof functionId !== 'string') {\n    return `${ functionId.address }::${ functionId.module }::${ functionId.functionName }`;\n  } else {\n    return functionId;\n  }\n}\n\nexport function parseFunctionId(\n  functionId: FunctionId\n): { address: AccountAddress; module: Identifier; functionName: Identifier } {\n  if (typeof functionId !== 'string') {\n    return functionId;\n  } else {\n    const parts = functionId.split('::', 3);\n    if (parts.length !== 3) {\n      throw new Error(`cannot parse ${ functionId } into FunctionId`);\n    }\n    return {\n      address: parts[0],\n      module: parts[1],\n      functionName: parts[2],\n    };\n  }\n}\n\nexport interface BlockHeaderView {\n  block_hash: HashValue;\n\n  parent_hash: HashValue;\n  timestamp: U64;\n  number: BlockNumber;\n  author: AccountAddress;\n  author_auth_key?: AuthenticationKey;\n  /// The transaction accumulator root hash after executing this block.\n  txn_accumulator_root: HashValue;\n  /// The parent block accumulator root hash.\n  block_accumulator_root: HashValue;\n  /// The last transaction state_root of this block after execute.\n  state_root: HashValue;\n  /// Gas used for contracts execution.\n  gas_used: U64;\n  /// Block difficulty\n  difficulty: U256;\n  /// Consensus nonce field.\n  nonce: U64;\n  /// hash for block body\n  body_hash: HashValue;\n  /// The chain id\n  chain_id: U8;\n}\n\ninterface BlockCommon {\n  header: BlockHeaderView;\n  confirmations?: number;\n}\n\nexport interface BlockWithTxnHashes extends BlockCommon {\n  transactions: HashValue[];\n}\n\nexport interface BlockWithTransactions extends BlockCommon {\n  transactions: Array<SignedUserTransactionView>;\n}\n\nexport interface BlockView extends BlockCommon {\n  transactions: Array<HashValue | SignedUserTransactionView>;\n}\n\nexport interface TxnBlockInfo {\n  block_hash: HashValue;\n  block_number: BlockNumber;\n  transaction_hash: HashValue;\n  transaction_index: number;\n}\n\nexport interface TransactionEventView extends TxnBlockInfo {\n  data: HexString;\n  type_tags: TypeTag;\n  event_key: EventKey;\n  event_seq_number: U64;\n}\n\nexport interface AccessPath {\n  address: AccountAddress;\n  path: HexString;\n}\n\nexport type WriteOp = 'Deletion' | { Value: HexString };\n\nexport interface TransactionWriteAction extends AccessPath {\n  action: WriteOp;\n}\n\nexport interface TransactionOutput {\n  gas_used: U64;\n  delta_size: I64;\n  status: TransactionVMStatus;\n  events: TransactionEventView[];\n  write_set: TransactionWriteAction[];\n}\n\nexport interface TransactionInfoView extends TxnBlockInfo {\n  state_root_hash: HashValue;\n  event_root_hash: HashValue;\n  gas_used: U64;\n  status: TransactionVMStatus;\n\n  txn_events?: Array<TransactionEventView>;\n\n  confirmations: number;\n}\n\nexport interface TransactionResponse extends SignedUserTransactionView {\n  // Only if a transaction has been mined\n  block_number?: BlockNumber;\n  block_hash?: HashValue;\n\n  confirmations: number;\n\n  // This function waits until the transaction has been mined\n  wait: (confirmations?: number) => Promise<TransactionInfoView>;\n}\n\nexport interface EventFilter {\n  event_keys?: EventKey[];\n  limit?: number;\n}\n\nexport interface Filter extends EventFilter {\n  from_block?: BlockNumber;\n  to_block?: BlockNumber;\n}\n\nexport interface OnchainEvent<T> {\n  address: AccountAddress;\n  eventId: uint64;\n  eventSequenceNumber: uint64;\n  eventData: T;\n}\n\nexport interface AcceptTokenEvent {\n  token_code: TokenCode;\n}\n\nexport interface TokenCode {\n  address: AccountAddress;\n  module: string;\n  name: string;\n}\n\nexport interface BlockRewardEvent {\n  block_number: uint64;\n  block_reward: uint128;\n  gas_fees: uint128;\n  miner: AccountAddress;\n}\n\nexport interface BurnEvent {\n  amount: uint128;\n  token_code: TokenCode;\n}\nexport interface MintEvent {\n  amount: uint128;\n  token_code: TokenCode;\n}\n\nexport interface DepositEvent {\n  amount: uint128;\n  token_code: TokenCode;\n  metadata: uint8[];\n}\nexport interface WithdrawEvent {\n  amount: uint128;\n  token_code: TokenCode;\n  metadata: uint8[];\n}\n\nexport interface NewBlockEvent {\n  number: uint64;\n  author: AccountAddress;\n\n  timestamp: uint64;\n  uncles: uint64;\n}\n\nexport interface ProposalCreatedEvent {\n  proposal_id: uint64;\n  proposer: AccountAddress;\n}\n\nexport interface VoteChangedEvent {\n  proposal_id: uint64;\n  proposer: AccountAddress;\n  voter: AccountAddress;\n  agree: boolean;\n  vote: uint128;\n}\n",
    "import { Deserializer } from './deserializer';\n\nexport abstract class BinaryDeserializer implements Deserializer {\n  private static readonly BIG_32 = BigInt(32);\n  private static readonly BIG_64 = BigInt(64);\n  private static readonly textDecoder = new TextDecoder();\n  public buffer: ArrayBuffer;\n  public offset: number;\n\n  protected constructor(data: Uint8Array) {\n    // As we can't be sure about the origin of the data, it's better to copy it to a new buffer\n    // e.g. if the data originated by: Buffer.from('16a9', 'hex'), the internal buffer would be much longer and/or different (as Buffer is some sort of a view)\n    this.buffer = new ArrayBuffer(data.length);\n    new Uint8Array(this.buffer).set(data, 0);\n    this.offset = 0;\n  }\n\n  private read(length: number): ArrayBuffer {\n    const bytes = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return bytes;\n  }\n\n  abstract deserializeLen(): number;\n\n  abstract deserializeVariantIndex(): number;\n\n  abstract checkThatKeySlicesAreIncreasing(\n      key1: [number, number],\n      key2: [number, number]\n  ): void;\n\n  public deserializeStr(): string {\n    const value = this.deserializeBytes();\n    return BinaryDeserializer.textDecoder.decode(value);\n  }\n\n  public deserializeBytes(): Uint8Array {\n    const len = this.deserializeLen();\n    if (len < 0) {\n      throw new Error(\"Length of a bytes array can't be negative\");\n    }\n    return new Uint8Array(this.read(len));\n  }\n\n  public deserializeBool(): boolean {\n    const bool = new Uint8Array(this.read(1))[0];\n    return bool == 1;\n  }\n\n  public deserializeUnit(): null {\n    return null;\n  }\n\n  public deserializeU8(): number {\n    return new DataView(this.read(1)).getUint8(0);\n  }\n\n  public deserializeU16(): number {\n    return new DataView(this.read(2)).getUint16(0, true);\n  }\n\n  public deserializeU32(): number {\n    return new DataView(this.read(4)).getUint32(0, true);\n  }\n\n  public deserializeU64(): BigInt {\n    const low = this.deserializeU32();\n    const high = this.deserializeU32();\n\n    // combine the two 32-bit values and return (little endian)\n    return (BigInt(high) << BinaryDeserializer.BIG_32) | BigInt(low);\n  }\n\n  public deserializeU128(): BigInt {\n    const low = this.deserializeU64();\n    const high = this.deserializeU64();\n\n    // combine the two 64-bit values and return (little endian)\n    return (BigInt(high) << BinaryDeserializer.BIG_64) | BigInt(low);\n  }\n\n  public deserializeI8(): number {\n    return new DataView(this.read(1)).getInt8(0);\n  }\n\n  public deserializeI16(): number {\n    return new DataView(this.read(2)).getInt16(0, true);\n  }\n\n  public deserializeI32(): number {\n    return new DataView(this.read(4)).getInt32(0, true);\n  }\n\n  public deserializeI64(): BigInt {\n    const low = this.deserializeI32();\n    const high = this.deserializeI32();\n\n    // combine the two 32-bit values and return (little endian)\n    return (BigInt(high) << BinaryDeserializer.BIG_32) | BigInt(low);\n  }\n\n  public deserializeI128(): BigInt {\n    const low = this.deserializeI64();\n    const high = this.deserializeI64();\n\n    // combine the two 64-bit values and return (little endian)\n    return (BigInt(high) << BinaryDeserializer.BIG_64) | BigInt(low);\n  }\n\n  public deserializeOptionTag(): boolean {\n    return this.deserializeBool();\n  }\n\n  public getBufferOffset(): number {\n    return this.offset;\n  }\n\n  public deserializeChar(): string {\n    throw new Error('Method deserializeChar not implemented.');\n  }\n\n  public deserializeF32(): number {\n    return new DataView(this.read(4)).getFloat32(0, true);\n  }\n\n  public deserializeF64(): number {\n    return new DataView(this.read(8)).getFloat64(0, true);\n  }\n}\n",
    "import { BinaryDeserializer } from '../serde/binaryDeserializer';\n\nexport class BcsDeserializer extends BinaryDeserializer {\n  private static readonly MAX_UINT_32 = 2 ** 32 - 1;\n\n  constructor(data: Uint8Array) {\n    super(data);\n  }\n\n  public deserializeUleb128AsU32(): number {\n    let value = 0;\n    for (let shift = 0; shift < 32; shift += 7) {\n      const x = this.deserializeU8();\n      const digit = x & 0x7f;\n      value = value | (digit << shift);\n      if (value < 0 || value > BcsDeserializer.MAX_UINT_32) {\n        throw new Error('Overflow while parsing uleb128-encoded uint32 value');\n      }\n      if (digit == x) {\n        if (shift > 0 && digit == 0) {\n          throw new Error('Invalid uleb128 number (unexpected zero digit)');\n        }\n        return value;\n      }\n    }\n    throw new Error('Overflow while parsing uleb128-encoded uint32 value');\n  }\n\n  deserializeLen(): number {\n    return this.deserializeUleb128AsU32();\n  }\n\n  public deserializeVariantIndex(): number {\n    return this.deserializeUleb128AsU32();\n  }\n\n  public checkThatKeySlicesAreIncreasing(\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      key1: [number, number],\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      key2: [number, number]\n  ): void {\n    return;\n  }\n}\n",
    "import { Serializer } from './serializer';\n\nexport abstract class BinarySerializer implements Serializer {\n    private static readonly BIG_32 = BigInt(32);\n    private static readonly BIG_64 = BigInt(64);\n\n    // TypeScript with target below es2016 will translate BigInt(2)**BigInt(32) to Math.pow(BigInt(2), BigInt(32))\n    // which will result in `Cannot convert a BigInt value to a number`\n    // parsing it directly from the string representation of the number will overcome it and allow es6 to be configured as well\n    private static readonly BIG_32Fs = BigInt('4294967295');\n    private static readonly BIG_64Fs = BigInt('18446744073709551615');\n\n    private static readonly textEncoder = new TextEncoder();\n    private buffer: ArrayBuffer;\n    private offset: number;\n\n    protected constructor() {\n        this.buffer = new ArrayBuffer(64);\n        this.offset = 0;\n    }\n\n    private ensureBufferWillHandleSize(bytes: number) {\n        while (this.buffer.byteLength < this.offset + bytes) {\n            const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);\n            new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));\n            this.buffer = newBuffer;\n        }\n    }\n\n    protected serialize(values: Uint8Array) {\n        this.ensureBufferWillHandleSize(values.length);\n        new Uint8Array(this.buffer, this.offset).set(values);\n        this.offset += values.length;\n    }\n\n    abstract serializeLen(value: number): void;\n\n    abstract serializeVariantIndex(value: number): void;\n\n    abstract sortMapEntries(offsets: number[]): void;\n\n    public serializeStr(value: string): void {\n        this.serializeBytes(BinarySerializer.textEncoder.encode(value));\n    }\n\n    public serializeBytes(value: Uint8Array): void {\n        this.serializeLen(value.length);\n        this.serialize(value);\n    }\n\n    public serializeBool(value: boolean): void {\n        const byteValue = value ? 1 : 0;\n        this.serialize(new Uint8Array([byteValue]));\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/explicit-module-boundary-types\n    public serializeUnit(value: null): void {\n        return;\n    }\n\n    private serializeWithFunction(\n        fn: (byteOffset: number, value: number, littleEndian: boolean) => void,\n        bytesLength: number,\n        value: number\n    ) {\n        this.ensureBufferWillHandleSize(bytesLength);\n        const dv = new DataView(this.buffer, this.offset);\n        fn.apply(dv, [0, value, true]);\n        this.offset += bytesLength;\n    }\n\n    public serializeU8(value: number): void {\n        this.serialize(new Uint8Array([value]));\n    }\n\n    public serializeU16(value: number): void {\n        this.serializeWithFunction(DataView.prototype.setUint16, 2, value);\n    }\n\n    public serializeU32(value: number): void {\n        this.serializeWithFunction(DataView.prototype.setUint32, 4, value);\n    }\n\n    public serializeU64(value: BigInt | number): void {\n        const low = BigInt(value) & BinarySerializer.BIG_32Fs;\n        const high = BigInt(value) >> BinarySerializer.BIG_32;\n\n        // write little endian number\n        this.serializeU32(Number(low));\n        this.serializeU32(Number(high));\n    }\n\n    public serializeU128(value: BigInt | number): void {\n        const low = BigInt(value) & BinarySerializer.BIG_64Fs;\n        const high = BigInt(value) >> BinarySerializer.BIG_64;\n\n        // write little endian number\n        this.serializeU64(low);\n        this.serializeU64(high);\n    }\n\n    public serializeI8(value: number): void {\n        const bytes = 1;\n        this.ensureBufferWillHandleSize(bytes);\n        new DataView(this.buffer, this.offset).setInt8(0, value);\n        this.offset += bytes;\n    }\n\n    public serializeI16(value: number): void {\n        const bytes = 2;\n        this.ensureBufferWillHandleSize(bytes);\n        new DataView(this.buffer, this.offset).setInt16(0, value, true);\n        this.offset += bytes;\n    }\n\n    public serializeI32(value: number): void {\n        const bytes = 4;\n        this.ensureBufferWillHandleSize(bytes);\n        new DataView(this.buffer, this.offset).setInt32(0, value, true);\n        this.offset += bytes;\n    }\n\n    public serializeI64(value: bigint | number): void {\n        const low = BigInt(value) & BinarySerializer.BIG_32Fs;\n        const high = BigInt(value) >> BinarySerializer.BIG_32;\n\n        // write little endian number\n        this.serializeI32(Number(low));\n        this.serializeI32(Number(high));\n    }\n\n    public serializeI128(value: bigint | number): void {\n        const low = BigInt(value) & BinarySerializer.BIG_64Fs;\n        const high = BigInt(value) >> BinarySerializer.BIG_64;\n\n        // write little endian number\n        this.serializeI64(low);\n        this.serializeI64(high);\n    }\n\n    public serializeOptionTag(value: boolean): void {\n        this.serializeBool(value);\n    }\n\n    public getBufferOffset(): number {\n        return this.offset;\n    }\n\n    public getBytes(): Uint8Array {\n        return new Uint8Array(this.buffer).slice(0, this.offset);\n    }\n\n    public serializeChar(value: string): void {\n        throw new Error('Method serializeChar not implemented.');\n    }\n\n    public serializeF32(value: number): void {\n        const bytes = 4;\n        this.ensureBufferWillHandleSize(bytes);\n        new DataView(this.buffer, this.offset).setFloat32(0, value, true);\n        this.offset += bytes;\n    }\n\n    public serializeF64(value: number): void {\n        const bytes = 8;\n        this.ensureBufferWillHandleSize(bytes);\n        new DataView(this.buffer, this.offset).setFloat64(0, value, true);\n        this.offset += bytes;\n    }\n}\n",
    "import { BinarySerializer } from '../serde/binarySerializer';\n\nexport class BcsSerializer extends BinarySerializer {\n    constructor() {\n        super();\n    }\n    public serializeU32AsUleb128(value: number): void {\n        const valueArray = [];\n        while (value >>> 7 != 0) {\n            valueArray.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        valueArray.push(value);\n        this.serialize(new Uint8Array(valueArray));\n    }\n\n    serializeLen(value: number): void {\n        this.serializeU32AsUleb128(value);\n    }\n\n    public serializeVariantIndex(value: number): void {\n        this.serializeU32AsUleb128(value);\n    }\n\n    public sortMapEntries(offsets: number[]) {\n        // leaving it empty for now, should be implemented soon\n    }\n}\n",
    "/* eslint-disable no-bitwise */\n\nexport function dec2bin(dec: number): string {\n  const bin = (dec >>> 0).toString(2)\n  const prefixed = `00000000000000000000000000000000${ bin }`\n  return prefixed.slice(-32);\n}\n\nexport function bin2dec(bin: string): number {\n  return Number.parseInt(Number.parseInt(bin, 2).toString(10), 10);\n}\n\n// the 3rd and 31st positions are set.\n// 268435457\n// 0b00010000000000000000000000000001\n// [0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001]\n// Uint8Array(4)[ 16, 0, 0, 1 ]\nexport function dec2uint8array(n: number): Uint8Array {\n  const arr = dec2bin(n).match(/.{1,8}/g);\n  const bitmap = Uint8Array.from(arr.map((str) => bin2dec(str)))\n  return bitmap\n}\n\nexport function uint8array2dec(bitmap: Uint8Array): number {\n  const binArr = []\n  bitmap.forEach((n) => binArr.push(dec2bin(n).slice(-8)))\n  return bin2dec(binArr.join(''))\n}\n\n\n\n// index from left to right\nexport function setBit(n: number, idx: number): number {\n  if (idx > 31 || idx < 0) {\n    throw new Error(`mask: invalid idx at ${ idx }, should be between 0 and 31`)\n  }\n  const mask = 1 << (32 - idx - 1)\n  return n | mask\n}\n\n// index from left to right\nexport function isSetBit(n: number, idx: number): boolean {\n  if (idx > 31 || idx < 0) {\n    throw new Error(`mask: invalid idx at ${ idx }, should be between 0 and 31`)\n  }\n  // const mask = 1 << (32 - idx - 1)\n  // let isSet = false\n  // if ((n & mask) !== 0) {\n  //   isSet = true\n  // }\n  // return isSet\n  return ((n >> (32 - idx - 1)) % 2 !== 0)\n}\n",
    "import { bech32 } from 'bech32';\nimport { concat, arrayify, hexlify } from '@ethersproject/bytes';\nimport { BcsDeserializer, BcsSerializer } from '../bcs';\nimport { Serializer } from '../serde/serializer';\nimport { Deserializer } from '../serde/deserializer';\nimport { Optional, Seq, Tuple, ListTuple, unit, bool, int8, int16, int32, int64, int128, uint8, uint16, uint32, uint64, uint128, float32, float64, char, str, bytes } from '../serde/types';\nimport { dec2bin, bin2dec, setBit, isSetBit, dec2uint8array, uint8array2dec } from \"../../../utils/helper\";\n\nconst CryptoMaterialError = {\n  SerializationError: 'Struct to be signed does not serialize correctly',\n  DeserializationError: 'Key or signature material does not deserialize correctly',\n  ValidationError: 'Key or signature material deserializes, but is otherwise not valid',\n  WrongLengthError: 'Key, threshold or signature material does not have the expected size',\n  CanonicalRepresentationError: 'Part of the signature or key is not canonical resulting to malleability issues',\n  SmallSubgroupError: 'A curve point (i.e., a public key) lies on a small group',\n  PointNotOnCurveError: 'A curve point (i.e., a public key) does not satisfy the curve equation',\n  BitVecError: 'BitVec errors in accountable multi-sig schemes',\n}\n\nconst MAX_NUM_OF_KEYS = 32\nconst BITMAP_NUM_OF_BYTES = 4\n\n// The length of the Ed25519PrivateKey\nconst ED25519_PRIVATE_KEY_LENGTH = 40;\n// The length of the Ed25519PublicKey\nconst ED25519_PUBLIC_KEY_LENGTH = 40;\n// The length of the Ed25519Signature\nconst ED25519_SIGNATURE_LENGTH = 40;\n\nexport class AccessPath {\n\n  constructor(public field0: AccountAddress, public field1: DataPath) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.field0.serialize(serializer);\n    this.field1.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): AccessPath {\n    const field0 = AccountAddress.deserialize(deserializer);\n    const field1 = DataPath.deserialize(deserializer);\n    return new AccessPath(field0, field1);\n  }\n\n}\nexport class AccountAddress {\n  static LENGTH: uint8 = 16;\n\n  constructor(public value: ListTuple<[uint8]>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    Helpers.serializeArray16U8Array(this.value, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): AccountAddress {\n    const value = Helpers.deserializeArray16U8Array(deserializer);\n    return new AccountAddress(value);\n  }\n\n}\nexport class AccountResource {\n\n  constructor(public authentication_key: Seq<uint8>, public withdrawal_capability: Optional<WithdrawCapabilityResource>, public key_rotation_capability: Optional<KeyRotationCapabilityResource>, public withdraw_events: EventHandle, public deposit_events: EventHandle, public accept_token_events: EventHandle, public sequence_number: uint64) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    Helpers.serializeVectorU8(this.authentication_key, serializer);\n    Helpers.serializeOptionWithdrawCapabilityResource(this.withdrawal_capability, serializer);\n    Helpers.serializeOptionKeyRotationCapabilityResource(this.key_rotation_capability, serializer);\n    this.withdraw_events.serialize(serializer);\n    this.deposit_events.serialize(serializer);\n    this.accept_token_events.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n  }\n\n  static deserialize(deserializer: Deserializer): AccountResource {\n    const authentication_key = Helpers.deserializeVectorU8(deserializer);\n    const withdrawal_capability = Helpers.deserializeOptionWithdrawCapabilityResource(deserializer);\n    const key_rotation_capability = Helpers.deserializeOptionKeyRotationCapabilityResource(deserializer);\n    const withdraw_events = EventHandle.deserialize(deserializer);\n    const deposit_events = EventHandle.deserialize(deserializer);\n    const accept_token_events = EventHandle.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    return new AccountResource(authentication_key, withdrawal_capability, key_rotation_capability, withdraw_events, deposit_events, accept_token_events, sequence_number);\n  }\n\n}\nexport class ArgumentABI {\n\n  constructor(public name: str, public type_tag: TypeTag) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.name);\n    this.type_tag.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ArgumentABI {\n    const name = deserializer.deserializeStr();\n    const type_tag = TypeTag.deserialize(deserializer);\n    return new ArgumentABI(name, type_tag);\n  }\n\n}\nexport class AuthenticationKey {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): AuthenticationKey {\n    const value = deserializer.deserializeBytes();\n    return new AuthenticationKey(value);\n  }\n\n}\nexport class BlockMetadata {\n\n  constructor(public parent_hash: HashValue, public timestamp: uint64, public author: AccountAddress, public author_auth_key: Optional<AuthenticationKey>, public uncles: uint64, public number: uint64, public chain_id: ChainId, public parent_gas_used: uint64) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.parent_hash.serialize(serializer);\n    serializer.serializeU64(this.timestamp);\n    this.author.serialize(serializer);\n    Helpers.serializeOptionAuthenticationKey(this.author_auth_key, serializer);\n    serializer.serializeU64(this.uncles);\n    serializer.serializeU64(this.number);\n    this.chain_id.serialize(serializer);\n    serializer.serializeU64(this.parent_gas_used);\n  }\n\n  static deserialize(deserializer: Deserializer): BlockMetadata {\n    const parent_hash = HashValue.deserialize(deserializer);\n    const timestamp = deserializer.deserializeU64();\n    const author = AccountAddress.deserialize(deserializer);\n    const author_auth_key = Helpers.deserializeOptionAuthenticationKey(deserializer);\n    const uncles = deserializer.deserializeU64();\n    const number = deserializer.deserializeU64();\n    const chain_id = ChainId.deserialize(deserializer);\n    const parent_gas_used = deserializer.deserializeU64();\n    return new BlockMetadata(parent_hash, timestamp, author, author_auth_key, uncles, number, chain_id, parent_gas_used);\n  }\n\n}\nexport class ChainId {\n\n  constructor(public id: uint8) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeU8(this.id);\n  }\n\n  static deserialize(deserializer: Deserializer): ChainId {\n    const id = deserializer.deserializeU8();\n    return new ChainId(id);\n  }\n\n}\nexport abstract class ContractEvent {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): ContractEvent {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return ContractEventVariantV0.load(deserializer);\n      default: throw new Error(\"Unknown variant index for ContractEvent: \" + index);\n    }\n  }\n}\n\n\nexport class ContractEventVariantV0 extends ContractEvent {\n\n  constructor(public value: ContractEventV0) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): ContractEventVariantV0 {\n    const value = ContractEventV0.deserialize(deserializer);\n    return new ContractEventVariantV0(value);\n  }\n\n}\nexport class ContractEventV0 {\n\n  constructor(public key: EventKey, public sequence_number: uint64, public type_tag: TypeTag, public event_data: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.key.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n    this.type_tag.serialize(serializer);\n    serializer.serializeBytes(this.event_data);\n  }\n\n  static deserialize(deserializer: Deserializer): ContractEventV0 {\n    const key = EventKey.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    const type_tag = TypeTag.deserialize(deserializer);\n    const event_data = deserializer.deserializeBytes();\n    return new ContractEventV0(key, sequence_number, type_tag, event_data);\n  }\n\n}\nexport abstract class DataPath {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): DataPath {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return DataPathVariantCode.load(deserializer);\n      case 1: return DataPathVariantResource.load(deserializer);\n      default: throw new Error(\"Unknown variant index for DataPath: \" + index);\n    }\n  }\n}\n\n\nexport class DataPathVariantCode extends DataPath {\n\n  constructor(public value: Identifier) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): DataPathVariantCode {\n    const value = Identifier.deserialize(deserializer);\n    return new DataPathVariantCode(value);\n  }\n\n}\n\nexport class DataPathVariantResource extends DataPath {\n\n  constructor(public value: StructTag) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): DataPathVariantResource {\n    const value = StructTag.deserialize(deserializer);\n    return new DataPathVariantResource(value);\n  }\n\n}\nexport abstract class DataType {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): DataType {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return DataTypeVariantCODE.load(deserializer);\n      case 1: return DataTypeVariantRESOURCE.load(deserializer);\n      default: throw new Error(\"Unknown variant index for DataType: \" + index);\n    }\n  }\n}\n\n\nexport class DataTypeVariantCODE extends DataType {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n  }\n\n  static load(deserializer: Deserializer): DataTypeVariantCODE {\n    return new DataTypeVariantCODE();\n  }\n\n}\n\nexport class DataTypeVariantRESOURCE extends DataType {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n  }\n\n  static load(deserializer: Deserializer): DataTypeVariantRESOURCE {\n    return new DataTypeVariantRESOURCE();\n  }\n\n}\nexport class Ed25519PrivateKey {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PrivateKey {\n    const value = deserializer.deserializeBytes();\n    return new Ed25519PrivateKey(value);\n  }\n\n}\nexport class Ed25519PublicKey {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PublicKey {\n    const value = deserializer.deserializeBytes();\n    return new Ed25519PublicKey(value);\n  }\n\n}\nexport class Ed25519Signature {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519Signature {\n    const value = deserializer.deserializeBytes();\n    return new Ed25519Signature(value);\n  }\n\n}\nexport class EventHandle {\n\n  constructor(public count: uint64, public key: EventKey) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeU64(this.count);\n    this.key.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): EventHandle {\n    const count = deserializer.deserializeU64();\n    const key = EventKey.deserialize(deserializer);\n    return new EventHandle(count, key);\n  }\n\n}\nexport class EventKey {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): EventKey {\n    const value = deserializer.deserializeBytes();\n    return new EventKey(value);\n  }\n\n}\nexport class HashValue {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): HashValue {\n    const value = deserializer.deserializeBytes();\n    return new HashValue(value);\n  }\n\n}\nexport class Identifier {\n\n  constructor(public value: str) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): Identifier {\n    const value = deserializer.deserializeStr();\n    return new Identifier(value);\n  }\n\n}\nexport class KeyRotationCapabilityResource {\n\n  constructor(public account_address: AccountAddress) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.account_address.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): KeyRotationCapabilityResource {\n    const account_address = AccountAddress.deserialize(deserializer);\n    return new KeyRotationCapabilityResource(account_address);\n  }\n\n}\nexport class Module {\n\n  constructor(public code: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.code);\n  }\n\n  static deserialize(deserializer: Deserializer): Module {\n    const code = deserializer.deserializeBytes();\n    return new Module(code);\n  }\n\n}\nexport class ModuleId {\n\n  constructor(public address: AccountAddress, public name: Identifier) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.address.serialize(serializer);\n    this.name.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ModuleId {\n    const address = AccountAddress.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    return new ModuleId(address, name);\n  }\n\n}\nexport class MultiEd25519PrivateKey {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519PrivateKey {\n    const value = deserializer.deserializeBytes();\n    return new MultiEd25519PrivateKey(value);\n  }\n\n}\nexport class MultiEd25519PublicKey {\n  constructor(public public_keys: Seq<Ed25519PublicKey>, public threshold: uint8) {\n    const num_of_public_keys = public_keys.length;\n    if (threshold === 0 || num_of_public_keys < threshold) {\n      throw new Error(CryptoMaterialError.ValidationError)\n    } else if (num_of_public_keys > MAX_NUM_OF_KEYS) {\n      throw new Error(CryptoMaterialError.WrongLengthError)\n    }\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519PublicKey {\n    const bytes = deserializer.deserializeBytes()\n    const public_keys: Seq<Ed25519PublicKey> = [];\n    const count = (bytes.length - 1) / 32\n    for (let i = 0; i < count; i++) {\n      const start = i * 32;\n      const end = start + 32;\n      public_keys.push(new Ed25519PublicKey(bytes.slice(start, end)));\n    }\n    const threshold = new DataView(bytes.slice(-1).buffer, 0).getUint8(0);;\n    return new MultiEd25519PublicKey(public_keys, threshold);\n  }\n\n  public value(): Uint8Array {\n    const arrPub = []\n    this.public_keys.forEach((pub) => {\n      arrPub.push(pub.value)\n    })\n\n    const arrThreshold = new Uint8Array(1);\n    arrThreshold[0] = this.threshold\n\n    const bytes = concat([...arrPub, ...arrThreshold])\n    return bytes;\n  }\n}\n\nexport class MultiEd25519Signature {\n  // 0b00010000000000000000000000000001(268435457), the 3rd and 31st positions are set.\n  constructor(public signatures: Seq<Ed25519Signature>, public bitmap: uint8) {\n  }\n\n  static build(origin_signatures: [Ed25519Signature, uint8][]): MultiEd25519Signature {\n    const num_of_sigs = origin_signatures.length;\n    if (num_of_sigs === 0 || num_of_sigs > MAX_NUM_OF_KEYS) {\n      throw new Error(CryptoMaterialError.ValidationError)\n    }\n    const sorted_signatures = origin_signatures.sort((a, b) => {\n      return a[1] > b[1] ? 1 : -1\n    })\n    const sigs = []\n    let bitmap = 0b00000000000000000000000000000000\n    sorted_signatures.forEach((k, v) => {\n      console.log(k, v)\n      if (k[1] >= MAX_NUM_OF_KEYS) {\n        throw new Error(`${ CryptoMaterialError.BitVecError }: Signature index is out of range`)\n      } else if (isSetBit(bitmap, k[1])) {\n        throw new Error(`${ CryptoMaterialError.BitVecError }: Duplicate signature index`)\n      } else {\n        sigs.push(k[0])\n        bitmap = setBit(bitmap, k[1])\n      }\n    })\n    return new MultiEd25519Signature(sigs, bitmap);\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519Signature {\n    const bytes = deserializer.deserializeBytes()\n    const signatures: Seq<Ed25519Signature> = [];\n    const count = (bytes.length - 4) / 64\n    for (let i = 0; i < count; i++) {\n      const start = i * 64;\n      const end = start + 64;\n      signatures.push(new Ed25519Signature(bytes.slice(start, end)));\n    }\n    const bitmap = uint8array2dec(bytes.slice(-4));\n    return new MultiEd25519Signature(signatures, bitmap);\n  }\n\n  public value(): Uint8Array {\n    const arrSignatures = []\n    this.signatures.forEach((signature) => {\n      arrSignatures.push(signature.value)\n    })\n\n    const arrBitmap = dec2uint8array(this.bitmap);\n\n    const bytes = concat([...arrSignatures, ...arrBitmap])\n    return bytes;\n  }\n}\n\nexport class MultiEd25519SignatureShard {\n  constructor(public signature: MultiEd25519Signature, public threshold: uint8) {\n  }\n\n  public signatures(): [Ed25519Signature, uint8][] {\n    const signatures = this.signature.signatures;\n    const bitmap = this.signature.bitmap;\n    const result: [Ed25519Signature, uint8][] = []\n    let bitmap_index = 0\n    signatures.forEach((v, idx) => {\n      while (!isSetBit(bitmap, bitmap_index)) {\n        bitmap_index += 1;\n      }\n      result.push([v, bitmap_index])\n      bitmap_index += 1\n    })\n    return result\n  }\n\n  static merge(shards: Seq<MultiEd25519SignatureShard>): MultiEd25519SignatureShard {\n    if (shards.length === 0) {\n      throw new Error('MultiEd25519SignatureShard shards is empty')\n    }\n    const threshold = shards[0].threshold\n    const signatures: [Ed25519Signature, uint8][] = []\n    shards.forEach((shard) => {\n      if (shard.threshold !== threshold) {\n        throw new Error('MultiEd25519SignatureShard shards threshold not same')\n      }\n      signatures.push(...shard.signatures())\n    })\n    return new MultiEd25519SignatureShard(MultiEd25519Signature.build(signatures), threshold)\n\n  }\n\n  public is_enough(): boolean {\n    return this.signature.signatures.length >= this.threshold\n  }\n}\n\n// Part of private keys in the multi-key Ed25519 structure along with the threshold.\n// note: the private keys must be a sequential part of the MultiEd25519PrivateKey\nexport class MultiEd25519KeyShard {\n  constructor(public public_keys: Seq<Ed25519PublicKey>, public threshold: uint8, public private_keys: Record<uint8, Ed25519PrivateKey>) {\n    const num_of_public_keys = public_keys.length;\n    const num_of_private_keys = Object.keys(private_keys).length;\n    if (threshold === 0 || num_of_private_keys === 0 || num_of_public_keys < threshold) {\n      throw new Error(CryptoMaterialError.ValidationError)\n    } else if (num_of_private_keys > MAX_NUM_OF_KEYS || num_of_public_keys > MAX_NUM_OF_KEYS) {\n      throw new Error(CryptoMaterialError.WrongLengthError)\n    }\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeU8(this.public_keys.length)\n    serializer.serializeU8(this.threshold)\n    serializer.serializeU8(this.len())\n    this.public_keys.forEach((pub) => {\n      pub.serialize(serializer)\n    })\n    Object.keys(this.private_keys).forEach((pos) => {\n      serializer.serializeU8(Number.parseInt(pos, 10))\n      this.private_keys[pos].serialize(serializer)\n    })\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519KeyShard {\n    const publicKeysLen = deserializer.deserializeU8();\n    const threshold = deserializer.deserializeU8();\n    const privateKeysLen = deserializer.deserializeU8();\n    const public_keys: Seq<Ed25519PublicKey> = [];\n    for (let i = 0; i < publicKeysLen; i++) {\n      public_keys.push(Ed25519PublicKey.deserialize(deserializer));\n    }\n    const private_keys: Record<uint8, Ed25519PrivateKey> = [];\n    for (let i = 0; i < privateKeysLen; i++) {\n      const pos = deserializer.deserializeU8()\n      const privateKey = Ed25519PrivateKey.deserialize(deserializer)\n      public_keys[pos] = privateKey\n    }\n    return new MultiEd25519KeyShard(public_keys, threshold, private_keys);\n  }\n\n  public publicKey(): MultiEd25519PublicKey {\n    return new MultiEd25519PublicKey(this.public_keys, this.threshold);\n  }\n\n  // should be different for each account, since the private_keys are not the same\n  public privateKeys(): Ed25519PrivateKey[] {\n    return Object.values(this.private_keys);\n  }\n\n  // should be different for each account, since the private_keys are not the same\n  public privateKey(): Uint8Array {\n    const arrHead = new Uint8Array(3);\n    arrHead[0] = this.public_keys.length\n    arrHead[1] = this.threshold\n    arrHead[2] = this.len()\n    const arrPub = []\n    this.public_keys.forEach((pub) => {\n      arrPub.push(pub.value)\n    })\n    const arrPriv = []\n    Object.values(this.private_keys).forEach((priv) => {\n      arrPriv.push(priv.value)\n    })\n    const bytes = concat([arrHead, ...arrPub, ...arrPriv])\n    return bytes;\n  }\n\n  public len(): uint8 {\n    return Object.values(this.private_keys).length;\n  }\n\n  public isEmpty(): boolean {\n    return this.len() === 0;\n  }\n}\n\nexport class Package {\n\n  constructor(public package_address: AccountAddress, public modules: Seq<Module>, public init_script: Optional<ScriptFunction>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.package_address.serialize(serializer);\n    Helpers.serializeVectorModule(this.modules, serializer);\n    Helpers.serializeOptionScriptFunction(this.init_script, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): Package {\n    const package_address = AccountAddress.deserialize(deserializer);\n    const modules = Helpers.deserializeVectorModule(deserializer);\n    const init_script = Helpers.deserializeOptionScriptFunction(deserializer);\n    return new Package(package_address, modules, init_script);\n  }\n\n}\nexport class RawUserTransaction {\n\n  constructor(public sender: AccountAddress, public sequence_number: uint64, public payload: TransactionPayload, public max_gas_amount: uint64, public gas_unit_price: uint64, public gas_token_code: str, public expiration_timestamp_secs: uint64, public chain_id: ChainId) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.sender.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n    this.payload.serialize(serializer);\n    serializer.serializeU64(this.max_gas_amount);\n    serializer.serializeU64(this.gas_unit_price);\n    serializer.serializeStr(this.gas_token_code);\n    serializer.serializeU64(this.expiration_timestamp_secs);\n    this.chain_id.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): RawUserTransaction {\n    const sender = AccountAddress.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    const payload = TransactionPayload.deserialize(deserializer);\n    const max_gas_amount = deserializer.deserializeU64();\n    const gas_unit_price = deserializer.deserializeU64();\n    const gas_token_code = deserializer.deserializeStr();\n    const expiration_timestamp_secs = deserializer.deserializeU64();\n    const chain_id = ChainId.deserialize(deserializer);\n    return new RawUserTransaction(sender, sequence_number, payload, max_gas_amount, gas_unit_price, gas_token_code, expiration_timestamp_secs, chain_id);\n  }\n}\nexport class Script {\n\n  constructor(public code: bytes, public ty_args: Seq<TypeTag>, public args: Seq<bytes>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.code);\n    Helpers.serializeVectorTypeTag(this.ty_args, serializer);\n    Helpers.serializeVectorBytes(this.args, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): Script {\n    const code = deserializer.deserializeBytes();\n    const ty_args = Helpers.deserializeVectorTypeTag(deserializer);\n    const args = Helpers.deserializeVectorBytes(deserializer);\n    return new Script(code, ty_args, args);\n  }\n\n}\nexport abstract class ScriptABI {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): ScriptABI {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return ScriptABIVariantTransactionScript.load(deserializer);\n      case 1: return ScriptABIVariantScriptFunction.load(deserializer);\n      default: throw new Error(\"Unknown variant index for ScriptABI: \" + index);\n    }\n  }\n}\n\n\nexport class ScriptABIVariantTransactionScript extends ScriptABI {\n\n  constructor(public value: TransactionScriptABI) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): ScriptABIVariantTransactionScript {\n    const value = TransactionScriptABI.deserialize(deserializer);\n    return new ScriptABIVariantTransactionScript(value);\n  }\n\n}\n\nexport class ScriptABIVariantScriptFunction extends ScriptABI {\n\n  constructor(public value: ScriptFunctionABI) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): ScriptABIVariantScriptFunction {\n    const value = ScriptFunctionABI.deserialize(deserializer);\n    return new ScriptABIVariantScriptFunction(value);\n  }\n\n}\nexport class ScriptFunction {\n  // need to rename `function` to `func` as `function` is a keyword in JS.\n  constructor(public module: ModuleId, public func: Identifier, public ty_args: Seq<TypeTag>, public args: Seq<bytes>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.module.serialize(serializer);\n    this.func.serialize(serializer);\n    Helpers.serializeVectorTypeTag(this.ty_args, serializer);\n    Helpers.serializeVectorBytes(this.args, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ScriptFunction {\n    const module = ModuleId.deserialize(deserializer);\n    const func = Identifier.deserialize(deserializer);\n    const ty_args = Helpers.deserializeVectorTypeTag(deserializer);\n    const args = Helpers.deserializeVectorBytes(deserializer);\n    return new ScriptFunction(module, func, ty_args, args);\n  }\n\n}\nexport class ScriptFunctionABI {\n\n  constructor(public name: str, public module_name: ModuleId, public doc: str, public ty_args: Seq<TypeArgumentABI>, public args: Seq<ArgumentABI>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.name);\n    this.module_name.serialize(serializer);\n    serializer.serializeStr(this.doc);\n    Helpers.serializeVectorTypeArgumentAbi(this.ty_args, serializer);\n    Helpers.serializeVectorArgumentAbi(this.args, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ScriptFunctionABI {\n    const name = deserializer.deserializeStr();\n    const module_name = ModuleId.deserialize(deserializer);\n    const doc = deserializer.deserializeStr();\n    const ty_args = Helpers.deserializeVectorTypeArgumentAbi(deserializer);\n    const args = Helpers.deserializeVectorArgumentAbi(deserializer);\n    return new ScriptFunctionABI(name, module_name, doc, ty_args, args);\n  }\n\n}\nexport class SignedUserTransaction {\n\n  constructor(public raw_txn: RawUserTransaction, public authenticator: TransactionAuthenticator) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.raw_txn.serialize(serializer);\n    this.authenticator.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): SignedUserTransaction {\n    const raw_txn = RawUserTransaction.deserialize(deserializer);\n    const authenticator = TransactionAuthenticator.deserialize(deserializer);\n    return new SignedUserTransaction(raw_txn, authenticator);\n  }\n\n  static ed25519(raw_txn: RawUserTransaction, public_key: Ed25519PublicKey, signature: Ed25519Signature): SignedUserTransaction {\n    const authenticator = new TransactionAuthenticatorVariantEd25519(public_key, signature);\n    return new SignedUserTransaction(raw_txn, authenticator);\n  }\n\n  static multi_ed25519(raw_txn: RawUserTransaction, public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature): SignedUserTransaction {\n    const authenticator = new TransactionAuthenticatorVariantMultiEd25519(public_key, signature);\n    return new SignedUserTransaction(raw_txn, authenticator);\n  }\n\n}\nexport class StructTag {\n\n  constructor(public address: AccountAddress, public module: Identifier, public name: Identifier, public type_params: Seq<TypeTag>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.address.serialize(serializer);\n    this.module.serialize(serializer);\n    this.name.serialize(serializer);\n    Helpers.serializeVectorTypeTag(this.type_params, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const module = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const type_params = Helpers.deserializeVectorTypeTag(deserializer);\n    return new StructTag(address, module, name, type_params);\n  }\n\n}\nexport abstract class Transaction {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): Transaction {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return TransactionVariantUserTransaction.load(deserializer);\n      case 1: return TransactionVariantBlockMetadata.load(deserializer);\n      default: throw new Error(\"Unknown variant index for Transaction: \" + index);\n    }\n  }\n}\n\n\nexport class TransactionVariantUserTransaction extends Transaction {\n\n  constructor(public value: SignedUserTransaction) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionVariantUserTransaction {\n    const value = SignedUserTransaction.deserialize(deserializer);\n    return new TransactionVariantUserTransaction(value);\n  }\n\n}\n\nexport class TransactionVariantBlockMetadata extends Transaction {\n\n  constructor(public value: BlockMetadata) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionVariantBlockMetadata {\n    const value = BlockMetadata.deserialize(deserializer);\n    return new TransactionVariantBlockMetadata(value);\n  }\n\n}\nexport abstract class TransactionArgument {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TransactionArgument {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return TransactionArgumentVariantU8.load(deserializer);\n      case 1: return TransactionArgumentVariantU64.load(deserializer);\n      case 2: return TransactionArgumentVariantU128.load(deserializer);\n      case 3: return TransactionArgumentVariantAddress.load(deserializer);\n      case 4: return TransactionArgumentVariantU8Vector.load(deserializer);\n      case 5: return TransactionArgumentVariantBool.load(deserializer);\n      default: throw new Error(\"Unknown variant index for TransactionArgument: \" + index);\n    }\n  }\n}\n\n\nexport class TransactionArgumentVariantU8 extends TransactionArgument {\n\n  constructor(public value: uint8) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n    serializer.serializeU8(this.value);\n  }\n\n  static load(deserializer: Deserializer): TransactionArgumentVariantU8 {\n    const value = deserializer.deserializeU8();\n    return new TransactionArgumentVariantU8(value);\n  }\n\n}\n\nexport class TransactionArgumentVariantU64 extends TransactionArgument {\n\n  constructor(public value: uint64) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n    serializer.serializeU64(this.value);\n  }\n\n  static load(deserializer: Deserializer): TransactionArgumentVariantU64 {\n    const value = deserializer.deserializeU64();\n    return new TransactionArgumentVariantU64(value);\n  }\n\n}\n\nexport class TransactionArgumentVariantU128 extends TransactionArgument {\n\n  constructor(public value: uint128) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(2);\n    serializer.serializeU128(this.value);\n  }\n\n  static load(deserializer: Deserializer): TransactionArgumentVariantU128 {\n    const value = deserializer.deserializeU128();\n    return new TransactionArgumentVariantU128(value);\n  }\n\n}\n\nexport class TransactionArgumentVariantAddress extends TransactionArgument {\n\n  constructor(public value: AccountAddress) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(3);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionArgumentVariantAddress {\n    const value = AccountAddress.deserialize(deserializer);\n    return new TransactionArgumentVariantAddress(value);\n  }\n\n}\n\nexport class TransactionArgumentVariantU8Vector extends TransactionArgument {\n\n  constructor(public value: bytes) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(4);\n    serializer.serializeBytes(this.value);\n  }\n\n  static load(deserializer: Deserializer): TransactionArgumentVariantU8Vector {\n    const value = deserializer.deserializeBytes();\n    return new TransactionArgumentVariantU8Vector(value);\n  }\n\n}\n\nexport class TransactionArgumentVariantBool extends TransactionArgument {\n\n  constructor(public value: bool) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(5);\n    serializer.serializeBool(this.value);\n  }\n\n  static load(deserializer: Deserializer): TransactionArgumentVariantBool {\n    const value = deserializer.deserializeBool();\n    return new TransactionArgumentVariantBool(value);\n  }\n\n}\nexport abstract class TransactionAuthenticator {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TransactionAuthenticator {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return TransactionAuthenticatorVariantEd25519.load(deserializer);\n      case 1: return TransactionAuthenticatorVariantMultiEd25519.load(deserializer);\n      default: throw new Error(\"Unknown variant index for TransactionAuthenticator: \" + index);\n    }\n  }\n}\n\n\nexport class TransactionAuthenticatorVariantEd25519 extends TransactionAuthenticator {\n\n  constructor(public public_key: Ed25519PublicKey, public signature: Ed25519Signature) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorVariantEd25519 {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorVariantEd25519(public_key, signature);\n  }\n\n}\n\nexport class TransactionAuthenticatorVariantMultiEd25519 extends TransactionAuthenticator {\n\n  constructor(public public_key: MultiEd25519PublicKey, public signature: MultiEd25519Signature) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorVariantMultiEd25519 {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorVariantMultiEd25519(public_key, signature);\n  }\n\n}\nexport abstract class TransactionPayload {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TransactionPayload {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return TransactionPayloadVariantScript.load(deserializer);\n      case 1: return TransactionPayloadVariantPackage.load(deserializer);\n      case 2: return TransactionPayloadVariantScriptFunction.load(deserializer);\n      default: throw new Error(\"Unknown variant index for TransactionPayload: \" + index);\n    }\n  }\n}\n\n\nexport class TransactionPayloadVariantScript extends TransactionPayload {\n\n  constructor(public value: Script) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadVariantScript {\n    const value = Script.deserialize(deserializer);\n    return new TransactionPayloadVariantScript(value);\n  }\n\n}\n\nexport class TransactionPayloadVariantPackage extends TransactionPayload {\n\n  constructor(public value: Package) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadVariantPackage {\n    const value = Package.deserialize(deserializer);\n    return new TransactionPayloadVariantPackage(value);\n  }\n\n}\n\nexport class TransactionPayloadVariantScriptFunction extends TransactionPayload {\n\n  constructor(public value: ScriptFunction) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(2);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadVariantScriptFunction {\n    const value = ScriptFunction.deserialize(deserializer);\n    return new TransactionPayloadVariantScriptFunction(value);\n  }\n\n}\nexport class TransactionScriptABI {\n\n  constructor(public name: str, public doc: str, public code: bytes, public ty_args: Seq<TypeArgumentABI>, public args: Seq<ArgumentABI>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.name);\n    serializer.serializeStr(this.doc);\n    serializer.serializeBytes(this.code);\n    Helpers.serializeVectorTypeArgumentAbi(this.ty_args, serializer);\n    Helpers.serializeVectorArgumentAbi(this.args, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): TransactionScriptABI {\n    const name = deserializer.deserializeStr();\n    const doc = deserializer.deserializeStr();\n    const code = deserializer.deserializeBytes();\n    const ty_args = Helpers.deserializeVectorTypeArgumentAbi(deserializer);\n    const args = Helpers.deserializeVectorArgumentAbi(deserializer);\n    return new TransactionScriptABI(name, doc, code, ty_args, args);\n  }\n\n}\nexport class TypeArgumentABI {\n\n  constructor(public name: str) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.name);\n  }\n\n  static deserialize(deserializer: Deserializer): TypeArgumentABI {\n    const name = deserializer.deserializeStr();\n    return new TypeArgumentABI(name);\n  }\n\n}\nexport abstract class TypeTag {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TypeTag {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return TypeTagVariantBool.load(deserializer);\n      case 1: return TypeTagVariantU8.load(deserializer);\n      case 2: return TypeTagVariantU64.load(deserializer);\n      case 3: return TypeTagVariantU128.load(deserializer);\n      case 4: return TypeTagVariantAddress.load(deserializer);\n      case 5: return TypeTagVariantSigner.load(deserializer);\n      case 6: return TypeTagVariantVector.load(deserializer);\n      case 7: return TypeTagVariantStruct.load(deserializer);\n      default: throw new Error(\"Unknown variant index for TypeTag: \" + index);\n    }\n  }\n}\n\n\nexport class TypeTagVariantBool extends TypeTag {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantBool {\n    return new TypeTagVariantBool();\n  }\n\n}\n\nexport class TypeTagVariantU8 extends TypeTag {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantU8 {\n    return new TypeTagVariantU8();\n  }\n\n}\n\nexport class TypeTagVariantU64 extends TypeTag {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(2);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantU64 {\n    return new TypeTagVariantU64();\n  }\n\n}\n\nexport class TypeTagVariantU128 extends TypeTag {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(3);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantU128 {\n    return new TypeTagVariantU128();\n  }\n\n}\n\nexport class TypeTagVariantAddress extends TypeTag {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(4);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantAddress {\n    return new TypeTagVariantAddress();\n  }\n\n}\n\nexport class TypeTagVariantSigner extends TypeTag {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(5);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantSigner {\n    return new TypeTagVariantSigner();\n  }\n\n}\n\nexport class TypeTagVariantVector extends TypeTag {\n\n  constructor(public value: TypeTag) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(6);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantVector {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagVariantVector(value);\n  }\n\n}\n\nexport class TypeTagVariantStruct extends TypeTag {\n\n  constructor(public value: StructTag) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(7);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVariantStruct {\n    const value = StructTag.deserialize(deserializer);\n    return new TypeTagVariantStruct(value);\n  }\n\n}\nexport class WithdrawCapabilityResource {\n\n  constructor(public account_address: AccountAddress) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.account_address.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): WithdrawCapabilityResource {\n    const account_address = AccountAddress.deserialize(deserializer);\n    return new WithdrawCapabilityResource(account_address);\n  }\n\n}\nexport abstract class WriteOp {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): WriteOp {\n    const index = deserializer.deserializeVariantIndex();\n    switch (index) {\n      case 0: return WriteOpVariantDeletion.load(deserializer);\n      case 1: return WriteOpVariantValue.load(deserializer);\n      default: throw new Error(\"Unknown variant index for WriteOp: \" + index);\n    }\n  }\n}\n\n\nexport class WriteOpVariantDeletion extends WriteOp {\n  constructor() {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(0);\n  }\n\n  static load(deserializer: Deserializer): WriteOpVariantDeletion {\n    return new WriteOpVariantDeletion();\n  }\n\n}\n\nexport class WriteOpVariantValue extends WriteOp {\n\n  constructor(public value: bytes) {\n    super();\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeVariantIndex(1);\n    serializer.serializeBytes(this.value);\n  }\n\n  static load(deserializer: Deserializer): WriteOpVariantValue {\n    const value = deserializer.deserializeBytes();\n    return new WriteOpVariantValue(value);\n  }\n\n}\nexport class WriteSet {\n\n  constructor(public value: WriteSetMut) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.value.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): WriteSet {\n    const value = WriteSetMut.deserialize(deserializer);\n    return new WriteSet(value);\n  }\n\n}\nexport class WriteSetMut {\n\n  constructor(public write_set: Seq<Tuple<[AccessPath, WriteOp]>>) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    Helpers.serializeVectorTuple2AccessPathWriteOp(this.write_set, serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): WriteSetMut {\n    const write_set = Helpers.deserializeVectorTuple2AccessPathWriteOp(deserializer);\n    return new WriteSetMut(write_set);\n  }\n\n}\nexport class Helpers {\n  static serializeArray16U8Array(value: ListTuple<[uint8]>, serializer: Serializer): void {\n    value.forEach((item) => {\n      serializer.serializeU8(item[0]);\n    });\n  }\n\n  static deserializeArray16U8Array(deserializer: Deserializer): ListTuple<[uint8]> {\n    const list: ListTuple<[uint8]> = [];\n    for (let i = 0; i < 16; i++) {\n      list.push([deserializer.deserializeU8()]);\n    }\n    return list;\n  }\n\n  static serializeOptionAuthenticationKey(value: Optional<AuthenticationKey>, serializer: Serializer): void {\n    if (value) {\n      serializer.serializeOptionTag(true);\n      value.serialize(serializer);\n    } else {\n      serializer.serializeOptionTag(false);\n    }\n  }\n\n  static deserializeOptionAuthenticationKey(deserializer: Deserializer): Optional<AuthenticationKey> {\n    const tag = deserializer.deserializeOptionTag();\n    if (!tag) {\n      return null;\n    } else {\n      return AuthenticationKey.deserialize(deserializer);\n    }\n  }\n\n  static serializeOptionKeyRotationCapabilityResource(value: Optional<KeyRotationCapabilityResource>, serializer: Serializer): void {\n    if (value) {\n      serializer.serializeOptionTag(true);\n      value.serialize(serializer);\n    } else {\n      serializer.serializeOptionTag(false);\n    }\n  }\n\n  static deserializeOptionKeyRotationCapabilityResource(deserializer: Deserializer): Optional<KeyRotationCapabilityResource> {\n    const tag = deserializer.deserializeOptionTag();\n    if (!tag) {\n      return null;\n    } else {\n      return KeyRotationCapabilityResource.deserialize(deserializer);\n    }\n  }\n\n  static serializeOptionScriptFunction(value: Optional<ScriptFunction>, serializer: Serializer): void {\n    if (value) {\n      serializer.serializeOptionTag(true);\n      value.serialize(serializer);\n    } else {\n      serializer.serializeOptionTag(false);\n    }\n  }\n\n  static deserializeOptionScriptFunction(deserializer: Deserializer): Optional<ScriptFunction> {\n    const tag = deserializer.deserializeOptionTag();\n    if (!tag) {\n      return null;\n    } else {\n      return ScriptFunction.deserialize(deserializer);\n    }\n  }\n\n  static serializeOptionWithdrawCapabilityResource(value: Optional<WithdrawCapabilityResource>, serializer: Serializer): void {\n    if (value) {\n      serializer.serializeOptionTag(true);\n      value.serialize(serializer);\n    } else {\n      serializer.serializeOptionTag(false);\n    }\n  }\n\n  static deserializeOptionWithdrawCapabilityResource(deserializer: Deserializer): Optional<WithdrawCapabilityResource> {\n    const tag = deserializer.deserializeOptionTag();\n    if (!tag) {\n      return null;\n    } else {\n      return WithdrawCapabilityResource.deserialize(deserializer);\n    }\n  }\n\n  static serializeTuple2AccessPathWriteOp(value: Tuple<[AccessPath, WriteOp]>, serializer: Serializer): void {\n    value[0].serialize(serializer);\n    value[1].serialize(serializer);\n  }\n\n  static deserializeTuple2AccessPathWriteOp(deserializer: Deserializer): Tuple<[AccessPath, WriteOp]> {\n    return [\n      AccessPath.deserialize(deserializer),\n      WriteOp.deserialize(deserializer)\n    ];\n  }\n\n  static serializeVectorArgumentAbi(value: Seq<ArgumentABI>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: ArgumentABI) => {\n      item.serialize(serializer);\n    });\n  }\n\n  static deserializeVectorArgumentAbi(deserializer: Deserializer): Seq<ArgumentABI> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<ArgumentABI> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(ArgumentABI.deserialize(deserializer));\n    }\n    return list;\n  }\n\n  static serializeVectorModule(value: Seq<Module>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: Module) => {\n      item.serialize(serializer);\n    });\n  }\n\n  static deserializeVectorModule(deserializer: Deserializer): Seq<Module> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<Module> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(Module.deserialize(deserializer));\n    }\n    return list;\n  }\n\n  static serializeVectorTypeArgumentAbi(value: Seq<TypeArgumentABI>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: TypeArgumentABI) => {\n      item.serialize(serializer);\n    });\n  }\n\n  static deserializeVectorTypeArgumentAbi(deserializer: Deserializer): Seq<TypeArgumentABI> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<TypeArgumentABI> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(TypeArgumentABI.deserialize(deserializer));\n    }\n    return list;\n  }\n\n  static serializeVectorTypeTag(value: Seq<TypeTag>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: TypeTag) => {\n      item.serialize(serializer);\n    });\n  }\n\n  static deserializeVectorTypeTag(deserializer: Deserializer): Seq<TypeTag> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<TypeTag> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(TypeTag.deserialize(deserializer));\n    }\n    return list;\n  }\n\n  static serializeVectorBytes(value: Seq<bytes>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: bytes) => {\n      serializer.serializeBytes(item);\n    });\n  }\n\n  static deserializeVectorBytes(deserializer: Deserializer): Seq<bytes> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<bytes> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(deserializer.deserializeBytes());\n    }\n    return list;\n  }\n\n  static serializeVectorTuple2AccessPathWriteOp(value: Seq<Tuple<[AccessPath, WriteOp]>>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: Tuple<[AccessPath, WriteOp]>) => {\n      Helpers.serializeTuple2AccessPathWriteOp(item, serializer);\n    });\n  }\n\n  static deserializeVectorTuple2AccessPathWriteOp(deserializer: Deserializer): Seq<Tuple<[AccessPath, WriteOp]>> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<Tuple<[AccessPath, WriteOp]>> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(Helpers.deserializeTuple2AccessPathWriteOp(deserializer));\n    }\n    return list;\n  }\n\n  static serializeVectorU8(value: Seq<uint8>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: uint8) => {\n      serializer.serializeU8(item);\n    });\n  }\n\n  static deserializeVectorU8(deserializer: Deserializer): Seq<uint8> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<uint8> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(deserializer.deserializeU8());\n    }\n    return list;\n  }\n\n}\n\nexport class AuthKey {\n\n  constructor(public value: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  public hex(): string {\n    return Buffer.from(this.value).toString('hex')\n  }\n\n}\n/**\n * Receipt Identifier\n * https://github.com/starcoinorg/SIPs/blob/master/sip-21/index.md\n * \n */\nexport class ReceiptIdentifier {\n  constructor(public accountAddress: AccountAddress, public authKey: Optional<AuthKey>) {\n  }\n\n  public encode(): string {\n    const VERSION = '1'\n    const PREFIX = 'stc'\n\n    const se = new BcsSerializer();\n    this.accountAddress.serialize(se);\n\n    const dataBuff = Buffer.concat([Buffer.from(se.getBytes()), Buffer.from(this.authKey.value)])\n    const words = bech32.toWords(dataBuff)\n    const wordsPrefixVersion = [Number(VERSION)].concat(words)\n    const encodedStr = bech32.encode(PREFIX, wordsPrefixVersion)\n    return encodedStr\n  }\n\n  static decode(value: string): ReceiptIdentifier {\n    const result = bech32.decode(value)\n    const wordsPrefixVersion = result.words\n\n    // const versionBytes = wordsPrefixVersion.slice(0, 1)\n    // const version = versionBytes.toString()\n\n    const words = wordsPrefixVersion.slice(1)\n\n    const dataBytes = Buffer.from(bech32.fromWords(words))\n\n    const accountAddressBytes = dataBytes.slice(0, AccountAddress.LENGTH)\n    const authKeyBytes = dataBytes.slice(AccountAddress.LENGTH)\n\n    const accountAddress = AccountAddress.deserialize(new BcsDeserializer(accountAddressBytes))\n    const authKey = new AuthKey(authKeyBytes)\n    return new ReceiptIdentifier(accountAddress, authKey)\n  }\n}\n\nexport class SigningMessage {\n\n  constructor(public message: bytes) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.message);\n  }\n\n  static deserialize(deserializer: Deserializer): SigningMessage {\n    const message = deserializer.deserializeBytes();\n    return new SigningMessage(message);\n  }\n\n}\n\nexport class SignedMessage {\n\n  constructor(public account: AccountAddress, public message: SigningMessage, public authenticator: TransactionAuthenticator, public chain_id: ChainId) {\n  }\n\n  public serialize(serializer: Serializer): void {\n    this.account.serialize(serializer);\n    this.message.serialize(serializer);\n    this.authenticator.serialize(serializer);\n    this.chain_id.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): SignedMessage {\n    const account = AccountAddress.deserialize(deserializer);\n    const message = SigningMessage.deserialize(deserializer);\n    const authenticator = TransactionAuthenticator.deserialize(deserializer);\n    const chain_id = ChainId.deserialize(deserializer);\n    return new SignedMessage(account, message, authenticator, chain_id);\n  }\n\n}\n",
    "import { arrayify, BytesLike } from '@ethersproject/bytes';\nimport { addHexPrefix } from 'ethereumjs-util';\n\nconst Buffer = require('safe-buffer').Buffer;\nconst sha3_256 = require('js-sha3').sha3_256;\n\nconst STARCOIN_HASH_PREFIX = 'STARCOIN::';\n\nclass DefaultHasher {\n  readonly salt?: Uint8Array;\n\n  constructor(typename?: string) {\n    if (typename) {\n      const data = new Uint8Array(Buffer.from(STARCOIN_HASH_PREFIX + typename));\n      const hasher = sha3_256.create();\n      hasher.update(data);\n      this.salt = new Uint8Array(hasher.arrayBuffer());\n    }\n  }\n\n  crypto_hash(data: BytesLike): string {\n    const hasher = sha3_256.create();\n    if (this.salt) {\n      hasher.update(this.salt);\n    }\n    hasher.update(arrayify(data));\n    return addHexPrefix(hasher.hex());\n  }\n\n  get_salt(): Uint8Array {\n    return this.salt;\n  }\n}\nexport interface CryptoHash {\n  crypto_hash(data: BytesLike): string;\n  get_salt(): Uint8Array;\n}\n\nexport function createHash(typename: string): CryptoHash {\n  return new DefaultHasher(typename);\n}\n\n\nexport function createUserTransactionHasher(): CryptoHash {\n  return createHash(\"SignedUserTransaction\");\n}\n\nexport function createRawUserTransactionHasher(): CryptoHash {\n  return createHash(\"RawUserTransaction\");\n}\n\nexport function createSigningMessageHasher(): CryptoHash {\n  return createHash(\"SigningMessage\");\n}\n",
    "export function toHexString(byteArray: Iterable<number>): string {\n  return '0x' + Buffer.from(new Uint8Array(byteArray)).toString('hex');\n}\n\nexport function fromHexString(hex: string, padding?: number): Uint8Array {\n  if (hex.startsWith('0x')) {\n    hex = hex.substring(2);\n  }\n  if (padding) {\n    if (hex.length < padding) {\n      hex = padLeft(hex, padding);\n    }\n  } else {\n    if (hex.length % 2 != 0) {\n      hex = '0' + hex;\n    }\n  }\n  const buf = Buffer.from(hex, 'hex');\n  return new Uint8Array(buf);\n}\n\n/**\n * @public\n * Should be called to pad string to expected length\n */\nexport function padLeft(str: string, chars: number, sign?: string) {\n  return new Array(chars - str.length + 1).join(sign ? sign : '0') + str;\n}\n\n/**\n * @public\n * Should be called to pad string to expected length\n */\nexport function padRight(str: string, chars: number, sign?: string) {\n  return str + new Array(chars - str.length + 1).join(sign ? sign : '0');\n}\n",
    "import { arrayify, BytesLike, hexlify } from '@ethersproject/bytes';\nimport { addHexPrefix, stripHexPrefix } from 'ethereumjs-util';\nimport * as ed from '@starcoin/stc-ed25519';\nimport { sha3_256 } from 'js-sha3';\nimport { createUserTransactionHasher } from \"../crypto_hash\";\nimport { BcsDeserializer, BcsSerializer } from '../lib/runtime/bcs';\nimport * as starcoin_types from '../lib/runtime/starcoin_types';\nimport * as serde from '../lib/runtime/serde';\nimport {\n  AccountAddress,\n  SignedUserTransactionView,\n  StructTag,\n  TransactionPayload,\n  TypeTag,\n  ReceiptIdentifierView,\n  accountType,\n} from '../types';\nimport { fromHexString, toHexString } from '../utils/hex';\nimport { Deserializer } from '../lib/runtime/serde';\n\nexport interface SerdeSerializable {\n  serialize(serializer: serde.Serializer): void;\n}\n\nexport interface Deserializable<T> {\n  deserialize(deserializer: Deserializer): T;\n}\n\nexport function bcsDecode<D extends Deserializable<T>, T>(\n  t: D,\n  data: BytesLike\n): T {\n  const de = new BcsDeserializer(arrayify(data));\n  return t.deserialize(de);\n}\n\nexport function bcsEncode(data: SerdeSerializable): string {\n  const se = new BcsSerializer();\n  data.serialize(se);\n  return toHexString(se.getBytes());\n}\n\nexport function decodeSignedUserTransaction(\n  data: BytesLike\n): SignedUserTransactionView {\n  const bytes = arrayify(data);\n  const scsData = (function () {\n    const de = new BcsDeserializer(bytes);\n    return starcoin_types.SignedUserTransaction.deserialize(de);\n  })();\n\n  let authenticator;\n  if (\n    scsData.authenticator instanceof\n    starcoin_types.TransactionAuthenticatorVariantEd25519\n  ) {\n    const publicKey = hexlify(scsData.authenticator.public_key.value);\n    const signature = hexlify(scsData.authenticator.signature.value);\n    authenticator = { Ed25519: { public_key: publicKey, signature } };\n  } else {\n    const auth = scsData.authenticator as starcoin_types.TransactionAuthenticatorVariantMultiEd25519;\n    const publicKey = hexlify(auth.public_key.value());\n    const signature = hexlify(auth.signature.value());\n    authenticator = { MultiEd25519: { public_key: publicKey, signature } };\n  }\n  const rawTxn = scsData.raw_txn;\n  const payload = (function () {\n    const se = new BcsSerializer();\n    rawTxn.payload.serialize(se);\n    return hexlify(se.getBytes());\n  })();\n  return {\n    transaction_hash: createUserTransactionHasher().crypto_hash(bytes),\n    raw_txn: {\n      sender: addressFromSCS(rawTxn.sender),\n      sequence_number: rawTxn.sequence_number,\n      payload,\n      max_gas_amount: rawTxn.max_gas_amount,\n      gas_unit_price: rawTxn.gas_unit_price,\n      gas_token_code: rawTxn.gas_token_code,\n      expiration_timestamp_secs: rawTxn.expiration_timestamp_secs,\n      chain_id: rawTxn.chain_id.id,\n    },\n    authenticator,\n  };\n}\n\n/// Decode a hex view or raw bytes of TransactionPayload into js struct.\nexport function decodeTransactionPayload(\n  payload: BytesLike\n): TransactionPayload {\n  const bytes = arrayify(payload);\n  const de = new BcsDeserializer(bytes);\n  const bcsTxnPayload = starcoin_types.TransactionPayload.deserialize(de);\n  if (bcsTxnPayload instanceof starcoin_types.TransactionPayloadVariantScript) {\n    const script = bcsTxnPayload.value;\n    return {\n      Script: {\n        code: toHexString(script.code),\n        ty_args: script.ty_args.map((t) => typeTagFromSCS(t)),\n        args: script.args.map((arg) => hexlify(arg)),\n      },\n    };\n  }\n\n  if (\n    bcsTxnPayload instanceof\n    starcoin_types.TransactionPayloadVariantScriptFunction\n  ) {\n    let scriptFunction = bcsTxnPayload.value;\n    return {\n      ScriptFunction: {\n        func: {\n          address: addressFromSCS(scriptFunction.module.address),\n          module: scriptFunction.module.name.value,\n          functionName: scriptFunction.func.value,\n        },\n        ty_args: scriptFunction.ty_args.map((t) => typeTagFromSCS(t)),\n        args: scriptFunction.args.map((arg) => hexlify(arg)),\n      },\n    };\n  }\n\n  if (\n    bcsTxnPayload instanceof starcoin_types.TransactionPayloadVariantPackage\n  ) {\n    const packagePayload = bcsTxnPayload.value;\n    return {\n      Package: {\n        package_address: addressFromSCS(packagePayload.package_address),\n        modules: packagePayload.modules.map((m) => ({\n          code: toHexString(m.code),\n        })),\n        init_script:\n          packagePayload.init_script === null\n            ? undefined\n            : {\n              func: {\n                address: addressFromSCS(\n                  packagePayload.init_script.module.address\n                ),\n                module: packagePayload.init_script.module.name.value,\n                functionName: packagePayload.init_script.func.value,\n              },\n              args: packagePayload.init_script.args.map((arg) =>\n                hexlify(arg)\n              ),\n              ty_args: packagePayload.init_script.ty_args.map((ty) =>\n                typeTagFromSCS(ty)\n              ),\n            },\n      },\n    };\n  }\n\n  throw new TypeError(`cannot decode bcs data ${ bcsTxnPayload }`);\n}\n\nexport function packageHexToTransactionPayload(\n  packageHex: string\n): starcoin_types.TransactionPayload {\n  const deserializer = new BcsDeserializer(arrayify(addHexPrefix(packageHex)))\n  const transactionPayload = starcoin_types.TransactionPayloadVariantPackage.load(deserializer)\n  return transactionPayload\n}\n\nexport function packageHexToTransactionPayloadHex(\n  packageHex: string\n): string {\n  const transactionPayload = packageHexToTransactionPayload(packageHex)\n  return bcsEncode(transactionPayload)\n}\n\nexport function addressToSCS(\n  addr: AccountAddress\n): starcoin_types.AccountAddress {\n  // AccountAddress should be 16 bytes, in hex, it's 16 * 2.\n  const bytes = fromHexString(addr, 16 * 2);\n  return starcoin_types.AccountAddress.deserialize(new BcsDeserializer(bytes));\n}\n\nexport function addressFromSCS(\n  addr: starcoin_types.AccountAddress\n): AccountAddress {\n  return toHexString(addr.value.map(([t]) => t));\n}\n\nexport function typeTagToSCS(ty: TypeTag): starcoin_types.TypeTag {\n  if (ty === 'Bool') {\n    return new starcoin_types.TypeTagVariantBool();\n  }\n  if (ty === 'U8') {\n    return new starcoin_types.TypeTagVariantU8();\n  }\n  if (ty === 'U128') {\n    return new starcoin_types.TypeTagVariantU128();\n  }\n  if (ty === 'U64') {\n    return new starcoin_types.TypeTagVariantU64();\n  }\n  if (ty === 'Address') {\n    return new starcoin_types.TypeTagVariantAddress();\n  }\n  if (ty === 'Signer') {\n    return new starcoin_types.TypeTagVariantSigner();\n  }\n  if ('Vector' in ty) {\n    return new starcoin_types.TypeTagVariantVector(typeTagToSCS(ty.Vector));\n  }\n  if ('Struct' in ty) {\n    return new starcoin_types.TypeTagVariantStruct(structTagToSCS(ty.Struct));\n  }\n  throw new Error(`invalid type tag: ${ ty }`);\n}\n\nexport function structTagToSCS(data: StructTag): starcoin_types.StructTag {\n  return new starcoin_types.StructTag(\n    addressToSCS(data.address),\n    new starcoin_types.Identifier(data.module),\n    new starcoin_types.Identifier(data.name),\n    data.type_params ? data.type_params.map((t) => typeTagToSCS(t)) : []\n  );\n}\n\nexport function structTagFromSCS(\n  bcs_data: starcoin_types.StructTag\n): StructTag {\n  return {\n    module: bcs_data.module.value,\n    name: bcs_data.name.value,\n    type_params: bcs_data.type_params.map((t) => typeTagFromSCS(t)),\n    address: addressFromSCS(bcs_data.address),\n  };\n}\n\n// eslint-disable-next-line consistent-return\nexport function typeTagFromSCS(bcs_data: starcoin_types.TypeTag): TypeTag {\n  if (bcs_data instanceof starcoin_types.TypeTagVariantAddress) {\n    return 'Address';\n  }\n  if (bcs_data instanceof starcoin_types.TypeTagVariantBool) {\n    return 'Bool';\n  }\n  if (bcs_data instanceof starcoin_types.TypeTagVariantU8) {\n    return 'U8';\n  }\n  if (bcs_data instanceof starcoin_types.TypeTagVariantU64) {\n    return 'U64';\n  }\n  if (bcs_data instanceof starcoin_types.TypeTagVariantU128) {\n    return 'U128';\n  }\n  if (bcs_data instanceof starcoin_types.TypeTagVariantSigner) {\n    return 'Signer';\n  }\n  if (bcs_data instanceof starcoin_types.TypeTagVariantStruct) {\n    return {\n      Struct: structTagFromSCS(bcs_data.value),\n    };\n  }\n  if (bcs_data instanceof starcoin_types.TypeTagVariantVector) {\n    return {\n      Vector: typeTagFromSCS(bcs_data.value),\n    };\n  }\n  throw new TypeError(`invalid bcs type tag: ${ bcs_data }`);\n}\n\nexport async function privateKeyToPublicKey(privateKey: string): Promise<string> {\n  const publicKey = await ed.getPublicKey(stripHexPrefix(privateKey))\n  return addHexPrefix(publicKey)\n}\n\n// singleMulti: 0-single, 1-multi\nexport function publicKeyToAuthKey(publicKey: string, singleMulti = accountType.SINGLE): string {\n  const hasher = sha3_256.create()\n  hasher.update(fromHexString(publicKey))\n  hasher.update(fromHexString(hexlify(singleMulti)))\n  const hash = hasher.hex()\n  return addHexPrefix(hash)\n}\n\n// singleMulti: 0-single, 1-multi\nexport function publicKeyToAddress(publicKey: string, singleMulti = accountType.SINGLE): string {\n  const hasher = sha3_256.create()\n  hasher.update(fromHexString(publicKey))\n  hasher.update(fromHexString(hexlify(singleMulti)))\n  const hash = hasher.hex()\n  const address = hash.slice(hash.length / 2)\n  return addHexPrefix(address)\n}\n\nexport function encodeReceiptIdentifier(addressStr: string, authKeyStr = ''): string {\n  const accountAddress = addressToSCS(addressStr)\n  const authKey = new starcoin_types.AuthKey(Buffer.from(authKeyStr, 'hex'))\n  return new starcoin_types.ReceiptIdentifier(accountAddress, authKey).encode();\n}\n\nexport function decodeReceiptIdentifier(value: string): ReceiptIdentifierView {\n  const receiptIdentifier = starcoin_types.ReceiptIdentifier.decode(value)\n  const accountAddress = stripHexPrefix(addressFromSCS(receiptIdentifier.accountAddress))\n  const authKey = receiptIdentifier.authKey.hex()\n  const receiptIdentifierView = { accountAddress, authKey }\n  return receiptIdentifierView\n}\n\nexport function publicKeyToReceiptIdentifier(publicKey: string): string {\n  const address = publicKeyToAddress(publicKey)\n  const authKey = publicKeyToAuthKey(publicKey)\n  const receiptIdentifier = encodeReceiptIdentifier(stripHexPrefix(address), stripHexPrefix(authKey))\n  return receiptIdentifier\n}\n\n// export function txnArgFromSCS(data: starcoin_types.TransactionArgument): TransactionArgument {\n//   if (data instanceof starcoin_types.TransactionArgumentVariantBool) {\n//     return { Bool: data.value };\n//   }\n//   if (data instanceof starcoin_types.TransactionArgumentVariantU8) {\n//     return { U8: data.value };\n//   }\n//   if (data instanceof starcoin_types.TransactionArgumentVariantU64) {\n//     return { U64: data.value };\n//   }\n//   if (data instanceof starcoin_types.TransactionArgumentVariantU128) {\n//     return { U128: data.value };\n//   }\n//   if (data instanceof starcoin_types.TransactionArgumentVariantAddress) {\n//     return { Address: addressFromSCS(data.value) };\n//   }\n//   if (data instanceof starcoin_types.TransactionArgumentVariantU8Vector) {\n//     return { U8Vector: data.value };\n//   }\n//   throw new TypeError(`cannot decode bcs type: ${data}`);\n// }\n\n// export function txnArgToSCS(\n//   data: TransactionArgument\n// ): starcoin_types.TransactionArgument {\n//   if ('U8' in data) {\n//     return new starcoin_types.TransactionArgumentVariantU8(data.U8);\n//   }\n//   if ('U64' in data) {\n//     return new starcoin_types.TransactionArgumentVariantU64(BigInt(data.U64));\n//   }\n//   if ('U128' in data) {\n//     return new starcoin_types.TransactionArgumentVariantU128(BigInt(data.U128));\n//   }\n//   if ('Address' in data) {\n//     return new starcoin_types.TransactionArgumentVariantAddress(\n//       addressToSCS(data.Address)\n//     );\n//   }\n//   if ('U8Vector' in data) {\n//     return new starcoin_types.TransactionArgumentVariantU8Vector(data.U8Vector);\n//   }\n//   if ('Bool' in data) {\n//     return new starcoin_types.TransactionArgumentVariantBool(data.Bool);\n//   }\n//   throw new Error(`invalid txn argument${data}`);\n//\n// }\n\n// Deprecated\n// stringToBytes(str) can be replaced with: new Uint8Array(Buffer.from(str))\nexport function stringToBytes(str: string): BytesLike {\n  let bytes = new Array();\n  let len, c;\n  len = str.length;\n  for (let i = 0; i < len; i++) {\n    c = str.charCodeAt(i);\n    if (c >= 0x010000 && c <= 0x10FFFF) {\n      bytes.push(((c >> 18) & 0x07) | 0xF0);\n      bytes.push(((c >> 12) & 0x3F) | 0x80);\n      bytes.push(((c >> 6) & 0x3F) | 0x80);\n      bytes.push((c & 0x3F) | 0x80);\n    } else if (c >= 0x000800 && c <= 0x00FFFF) {\n      bytes.push(((c >> 12) & 0x0F) | 0xE0);\n      bytes.push(((c >> 6) & 0x3F) | 0x80);\n      bytes.push((c & 0x3F) | 0x80);\n    } else if (c >= 0x000080 && c <= 0x0007FF) {\n      bytes.push(((c >> 6) & 0x1F) | 0xC0);\n      bytes.push((c & 0x3F) | 0x80);\n    } else {\n      bytes.push(c & 0xFF);\n    }\n  }\n  return bytes;\n}\n\n// Deprecated\n// bytesToString(arr) can be replaced with: Buffer.from(arr).toString()\nexport function bytesToString(arr: BytesLike): string {\n  if (typeof arr === 'string') {\n    return arr;\n  }\n  let str = '';\n  for (let i = 0; i < arr.length; i++) {\n    let one = arr[i].toString(2),\n      v = one.match(/^1+?(?=0)/);\n    if (v && one.length == 8) {\n      let bytesLength = v[0].length;\n      let store = arr[i].toString(2).slice(7 - bytesLength);\n      for (let st = 1; st < bytesLength; st++) {\n        store += arr[st + i].toString(2).slice(2);\n      }\n      str += String.fromCharCode(parseInt(store, 2));\n      i += bytesLength - 1;\n    } else {\n      str += String.fromCharCode(arr[i]);\n    }\n  }\n  return str;\n}\n",
    "import { BcsDeserializer } from \"../lib/runtime/bcs\";\nimport * as starcoin_types from \"../lib/runtime/starcoin_types\";\nimport { ScriptABI } from \"../types\";\nimport * as bcs_to_json from \"../encoding\";\n\nexport function decodeTransactionScriptABI(bytes: Uint8Array): ScriptABI {\n  const de = new BcsDeserializer(bytes);\n  const abi = starcoin_types.TransactionScriptABI.deserialize(de);\n  return {\n    args: abi.args.map((a) => ({\n      name: a.name,\n      type_tag: bcs_to_json.typeTagFromSCS(a.type_tag),\n    })),\n    code: abi.code,\n    doc: abi.doc,\n    name: abi.name,\n    ty_args: abi.ty_args.map((t) => ({\n      name: t.name,\n    })),\n  };\n}\n",
    "\nimport { utils } from '@starcoin/stc-ed25519';\nimport { addHexPrefix, stripHexPrefix } from 'ethereumjs-util';\nimport { hexlify, arrayify } from '@ethersproject/bytes';\nimport { privateKeyToPublicKey, publicKeyToAuthKey, publicKeyToAddress, encodeReceiptIdentifier, bcsEncode } from \"../encoding\";\nimport { MultiEd25519KeyShard, Ed25519PublicKey, Ed25519PrivateKey } from \"../lib/runtime/starcoin_types\";\nimport { accountType } from \"../types\";\n\nexport function generatePrivateKey(): string {\n  // 32-byte Uint8Array\n  const privateKeyBytes = utils.randomPrivateKey();\n  const privateKey = Buffer.from(privateKeyBytes).toString('hex');\n  return addHexPrefix(privateKey);\n}\n\nexport async function generateAccount(): Promise<Record<string, string>> {\n  const privateKey = generatePrivateKey();\n  const accountInfo = showAccount(privateKey);\n  return accountInfo;\n}\n\n/**\n * simillar to these 2 commands in starcoin console:\n * starcoin% account import -i <PRIVATEKEY>\n * starcoin% account show <ACCOUNT_ADDRESS>\n * @param privateKey\n * @returns \n */\nexport async function showAccount(privateKey: string): Promise<Record<string, string>> {\n  const publicKey = await privateKeyToPublicKey(privateKey)\n  const address = publicKeyToAddress(publicKey)\n  const authKey = publicKeyToAuthKey(publicKey)\n  const receiptIdentifier = encodeReceiptIdentifier(stripHexPrefix(address), stripHexPrefix(authKey))\n  return {\n    privateKey,\n    publicKey,\n    address,\n    authKey,\n    receiptIdentifier\n  };\n}\n\nexport function getMultiEd25519AccountPrivateKey(shard: MultiEd25519KeyShard): string {\n  const privateKey = hexlify(shard.privateKey())\n  return privateKey;\n}\n\nexport function getMultiEd25519AccountPublicKey(shard: MultiEd25519KeyShard): string {\n  const multiEd25519PublicKey = shard.publicKey()\n  const publicKey = hexlify(multiEd25519PublicKey.value())\n  return publicKey;\n}\n\nexport function getMultiEd25519AccountAddress(shard: MultiEd25519KeyShard): string {\n  const publicKey = getMultiEd25519AccountPublicKey(shard)\n  const address = publicKeyToAddress(publicKey, accountType.MULTI)\n  return address;\n}\n\nexport function getMultiEd25519AccountReceiptIdentifier(shard: MultiEd25519KeyShard): string {\n  const address = getMultiEd25519AccountAddress(shard)\n  // same with Rust, receiptIdentifier do not include authKey\n  const receiptIdentifier = encodeReceiptIdentifier(stripHexPrefix(address))\n  return receiptIdentifier;\n}\n\nexport function showMultiEd25519Account(shard: MultiEd25519KeyShard): Record<string, string> {\n  const privateKey = getMultiEd25519AccountPrivateKey(shard)\n  const publicKey = getMultiEd25519AccountPublicKey(shard)\n  const address = getMultiEd25519AccountAddress(shard)\n  const receiptIdentifier = getMultiEd25519AccountReceiptIdentifier(shard)\n  const authKey = publicKeyToAuthKey(publicKey, accountType.MULTI)\n\n  return {\n    privateKey,\n    publicKey,\n    address,\n    authKey,\n    receiptIdentifier\n  };\n}\n\nexport function decodeMultiEd25519AccountPrivateKey(privateKey: string): Record<string, any> {\n  const bytes = arrayify(privateKey)\n  const publicKeysLengthBytes = bytes.slice(0, 1);\n  const publicKeysLength = publicKeysLengthBytes[0];\n\n  const thresholdBytes = bytes.slice(1, 2);\n  const threshold = thresholdBytes[0];\n\n  const privateKeysLengthBytes = bytes.slice(2, 3);\n  const privateKeysLength = privateKeysLengthBytes[0];\n\n  const publicKeys = []\n  const privateKeys = []\n  let start = 3\n  const length = 40\n  let end\n\n  for (let i = 0; i < publicKeysLength; i += 1) {\n    end = start + length\n    const publicKeyBytes = bytes.slice(start, end);\n    publicKeys.push(hexlify(publicKeyBytes))\n    start = end\n  }\n  for (let i = 0; i < privateKeysLength; i += 1) {\n    end = start + length\n    const privateKeyBytes = bytes.slice(start, end);\n    privateKeys.push(hexlify(privateKeyBytes))\n    start = end\n  }\n\n  return { privateKeys, publicKeys, threshold };\n}",
    "export function InvalidNumberOfMoveArgs(given: number, expected: number) {\n  return new Error(\n    `Invalid number of arguments to Move function. given: ${given}, expected: ${expected}`\n  );\n}\n\nexport function InvalidNumberOfRPCParams(\n  methodName: string,\n  given: number,\n  expected: number\n) {\n  return new Error(\n    `Invalid number of input parameters to RPC method \"${methodName}\" given: ${given}, expected: ${expected}`\n  );\n}\n\nexport function InvalidConnection(host: string) {\n  return new Error(\"CONNECTION ERROR: Couldn't connect to node \" + host + '.');\n}\n\nexport function InvalidProvider() {\n  return new Error('Provider not set or invalid');\n}\n\nexport function InvalidResponse(result: any) {\n  const message =\n    !!result && !!result.error && !!result.error.message\n      ? result.error.message\n      : 'Invalid JSON RPC response: ' + JSON.stringify(result);\n  return new Error(message);\n}\n\nexport function ConnectionTimeout(ms: number) {\n  return new Error('CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');\n}\n",
    "import hexadecimal from 'is-hexadecimal';\nimport decimal from 'is-decimal';\nimport alphanumerical from 'is-alphanumerical';\nimport alphabetical from 'is-alphabetical';\nimport whitespace from 'is-whitespace-character';\nimport {  TypeTag } from '../types';\nimport { fromHexString } from './hex';\n\ntype Token =\n  'U8Type'\n  | 'U64Type'\n  | 'U128Type'\n  | 'BoolType'\n  | 'AddressType'\n  | 'VectorType'\n  | { WhiteSpace: string }\n  | { Name: string }\n  | { Address: string }\n  | { U8: string }\n  | { U64: string }\n  | { U128: string }\n  | { Bytes: string }\n  | 'True'\n  | 'False'\n  | 'ColonColon'\n  | 'Lt'\n  | 'Gt'\n  | 'Comma'\n  | 'EOF';\n\n\nclass Parser {\n  readonly toks: Token[];\n  private cur_idx: number = 0;\n\n  constructor(toks: Token[]) {\n    this.toks = toks;\n  }\n\n  next_tok(): Token {\n    let tok = this.toks[this.cur_idx++];\n    if (tok === undefined) {\n      throw new Error('out of token, this should not happen');\n    }\n    return tok;\n  }\n\n  peek(): Token | undefined {\n    return this.toks[this.cur_idx];\n  }\n\n  consume_tok(tok: Token) {\n    let t = this.next_tok();\n    if (t != tok) {\n      throw new Error(`expected tok: ${tok}, got: ${t}`);\n    }\n  }\n\n  parse_comma_list<R>(parse_list_item: (x: Parser) => R, end_token: Token, allow_trailing_comma: boolean): R[] {\n    let v = [];\n    const head = this.peek();\n    if (!(head === end_token)) {\n      while (true) {\n        v.push(parse_list_item(this));\n        if (this.peek() === end_token) {\n          break;\n        }\n        this.consume_tok('Comma');\n        if (this.peek() === end_token && allow_trailing_comma) {\n          break;\n        }\n      }\n    }\n    return v;\n  }\n\n  parseTypeTag(): TypeTag {\n    let tok = this.next_tok();\n    if (tok === 'U8Type') {\n      return 'U8';\n    }\n    if (tok === 'U64Type') {\n      return 'U64';\n    }\n    if (tok === 'U128Type') {\n      return 'U128';\n    }\n    if (tok === 'BoolType') {\n      return 'Bool';\n    }\n    if (tok === 'AddressType') {\n      return 'Address';\n    }\n    if (tok === 'VectorType') {\n      this.consume_tok('Lt');\n      let ty = this.parseTypeTag();\n      this.consume_tok('Gt');\n      return { Vector: ty };\n    }\n    if (tok['Address'] !== undefined) {\n      let addr = tok['Address'];\n      this.consume_tok('ColonColon');\n\n      let module_tok = this.next_tok();\n      if (module_tok['Name'] === undefined) {\n        throw new Error(`expected name, got: ${module_tok}`);\n      }\n      let module = module_tok['Name'];\n\n      this.consume_tok('ColonColon');\n      let struct_tok = this.next_tok();\n\n      if (struct_tok['Name'] === undefined) {\n        throw new Error(`expected name, got: ${module_tok}`);\n      }\n\n      let struct_name = struct_tok['Name'];\n\n      let tyArgs = [];\n      if (this.peek() === 'Lt') {\n        this.consume_tok('Lt');\n        tyArgs = this.parse_comma_list(p => p.parseTypeTag(), 'Gt', true);\n        this.consume_tok('Gt');\n      }\n\n      return {\n        Struct: {\n          address: addr,\n          module: module,\n          name: struct_name,\n          type_params: tyArgs\n        }\n      };\n    }\n\n    throw new Error(`unexpected token ${tok}, expected type tag`);\n  }\n\n  // parseTransactionArgument(): TransactionArgument {\n  //   let tok = this.next_tok();\n  //   // @ts-ignore\n  //   if (tok.U8 !== undefined) {\n  //     // @ts-ignore\n  //     return {U8: Number.parseInt(tok.U8)};\n  //   }\n  //   // @ts-ignore\n  //   if (tok.U64 !== undefined) {\n  //     // @ts-ignore\n  //     return {U64: BigInt(tok.U64)};\n  //   }\n  //   // @ts-ignore\n  //   if (tok.U128 !== undefined) {\n  //     // @ts-ignore\n  //     return {U128: BigInt(tok.U128)};\n  //   }\n  //\n  //\n  //   if (tok === 'True') {\n  //     return {Bool: true};\n  //   }\n  //   if (tok === 'False') {\n  //     return {Bool: false};\n  //   }\n  //\n  //   // @ts-ignore\n  //   if (tok.Address!==undefined) {\n  //     // @ts-ignore\n  //     return {Address: tok.Address };\n  //   }\n  //   // @ts-ignore\n  //   if (tok.Bytes!==undefined) {\n  //     // @ts-ignore\n  //     return {U8Vector: fromHexString(tok.Bytes)};\n  //   }\n  //\n  //   throw new Error(`unexpected token ${tok}, expected transaction argument`);\n  // }\n}\n\n// parse a number from string.\nfunction nextNumber(s: string): [Token, number] {\n  let num = '';\n  let i = 0;\n  while (i < s.length) {\n    let c = s[i++];\n    // parse number\n    if (decimal(c)) {\n      num = num.concat(c);\n    } else if (alphabetical(c)) { // if come across a char, parse as suffix.\n      let suffix = c;\n      while (i < s.length) {\n        let c = s[i++];\n        if (alphanumerical(c)) {\n          suffix = suffix.concat(c);\n        } else {\n          break;\n        }\n      }\n      const len = num.length + suffix.length;\n      switch (suffix) {\n        case 'u8':\n          return [{ U8: num }, len];\n        case 'u64':\n          return [{ U64: num }, len];\n        case 'u128':\n          return [{ U128: num }, len];\n        default:\n          throw new Error('invalid suffix');\n      }\n    } else {\n      break;\n    }\n  }\n  return [{ U64: num }, num.length];\n}\n\nfunction nameToken(s: string): Token {\n  switch (s) {\n    case 'u8':\n      return 'U8Type';\n    case 'u64':\n      return 'U64Type';\n    case 'u128':\n      return 'U128Type';\n    case 'bool':\n      return 'BoolType';\n    case 'address':\n      return 'AddressType';\n    case 'vector':\n      return 'VectorType';\n    case 'true':\n      return 'True';\n    case 'false':\n      return 'False';\n    default:\n      return { Name: s };\n  }\n}\nfunction nextToken(s: string): [Token, number] | undefined {\n  if (s.length === 0) {\n    return undefined;\n  }\n  let head = s[0];\n  if (head === '<') {\n    return ['Lt', 1];\n  }\n  if (head === '>') {\n    return ['Gt', 1];\n  }\n  if (head === ',') {\n    return ['Comma', 1];\n  }\n\n  if (head === ':') {\n    if (s[1] === ':') {\n      return ['ColonColon', 2];\n    } else {\n      throw new Error('unrecognized token');\n    }\n  }\n  if (head === '0' && ['x', 'X'].includes(s[1])) {\n    if (hexadecimal(s[2])) {\n      let r = '0x';\n      for (let i = 2; i < s.length; i++) {\n        if (hexadecimal(s[i])) {\n          r = r.concat(s[i]);\n        } else {\n          break;\n        }\n      }\n      return [{ Address: r }, r.length];\n    } else {\n      throw new Error('unrecognized token');\n    }\n  }\n  if (decimal(head)) {\n    return nextNumber(s);\n  }\n\n  // parse bytes start with b.\n  if (head === 'b' && s[1] === '\"') {\n    let r = '';\n    let i = 2;\n    while (true) {\n      if (i >= s.length) {\n        throw new Error('unrecognized token');\n      }\n      let c = s[i++];\n      if (c === '\"') {\n        break;\n      } else if (isAscii(c)) {\n        r = r.concat(c);\n      } else {\n        throw new Error('unrecognized token');\n      }\n    }\n\n    return [{ Bytes: r }, r.length + 3];\n  }\n\n  // parse bytes start with x.\n  if (head === 'x' && s[1] === '\"') {\n    let r = '';\n    let i = 2;\n    while (true) {\n      if (i >= s.length) {\n        throw new Error('unrecognized token');\n      }\n      let c = s[i++];\n      if (c === '\"') {\n        break;\n      } else if (hexadecimal(c)) {\n        r = r.concat(c);\n      } else {\n        throw new Error('unrecognized token');\n      }\n    }\n    return [{ Bytes: r }, r.length + 3];\n  }\n\n\n  // parse name token.\n  if (alphabetical(head) || ['-','_'].includes(head)) {\n    let r = '';\n    for (let i = 0; i < s.length; i++) {\n      if (alphanumerical(s[i]) || ['-','_'].includes(s[i])) {\n        r = r.concat(s[i]);\n      } else {\n        break;\n      }\n    }\n    return [nameToken(r), r.length];\n  }\n\n  // parse whitespace.\n  if (whitespace(head)) {\n    let r = '';\n    for (let i = 0; i < s.length; i++) {\n      if (whitespace(s[i])) {\n        r = r.concat(s[i]);\n      } else {\n        break;\n      }\n    }\n    return [{ WhiteSpace: r }, r.length];\n  }\n\n  throw new Error('unrecognized token');\n}\n\nfunction tokenize(s: string): Token[] {\n  let v = [];\n  while (true) {\n    // @ts-ignore\n    let nextTok = nextToken(s);\n    if (nextTok === undefined) {\n      break;\n    }\n    let [tok, n] = nextTok;\n    v.push(tok);\n    s = s.substring(n);\n  }\n  return v;\n}\n\n\n\n\nfunction isAscii(character): boolean {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character;\n\n  return code <= 0x7F;\n}\n\n\nfunction parse<T>(s: string, f: (p: Parser) => T): T {\n  // @ts-ignore\n  let toks = tokenize(s).filter(t => t.WhiteSpace === undefined);\n  toks.push('EOF');\n  let parser = new Parser(toks);\n  let res = f(parser);\n  parser.consume_tok('EOF');\n  return res;\n}\n\nexport function parseTypeTags(s: string): TypeTag[] {\n  return parse(s, p => {\n    return p.parse_comma_list(p => p.parseTypeTag(), 'EOF', true);\n  });\n}\nexport function parseTypeTag(s: string): TypeTag {\n  return parse(s, p => p.parseTypeTag());\n}\n\n// export fuction parseTransactionArguments(s: string): TransactionArgument[] {\n//   return parse(s, p => {\n//     return p.parse_comma_list(p => p.parseTransactionArgument(), 'EOF', true);\n//   });\n// }\n// export function parseTransactionArgument(s: string): TransactionArgument {\n//   return parse(s, p => p.parseTransactionArgument());\n// }\n",
    "// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst packageJson = require('../package.json');\n\nexport const { version } = packageJson;\n",
    "import { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../version\";\nconst logger = new Logger(version);\n\nexport function checkProperties(object: any, properties: { [name: string]: boolean }): void {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}",
    "import * as ed from '@starcoin/stc-ed25519';\nimport { addHexPrefix, stripHexPrefix } from 'ethereumjs-util';\nimport { arrayify, hexlify, BytesLike } from '@ethersproject/bytes';\nimport { BcsSerializer, BcsDeserializer } from '../lib/runtime/bcs';\nimport { createSigningMessageHasher } from \"../crypto_hash\";\nimport {\n  Ed25519PublicKey, Ed25519Signature, TransactionAuthenticator,\n  TransactionAuthenticatorVariantEd25519, TransactionAuthenticatorVariantMultiEd25519,\n  SignedMessage, SigningMessage, AccountAddress, ChainId\n} from '../lib/runtime/starcoin_types';\nimport { bytes, uint8 } from '../lib/runtime/serde/types';\nimport { privateKeyToPublicKey, publicKeyToAuthKey, publicKeyToAddress, addressToSCS, addressFromSCS, bcsEncode } from \"../encoding\";\n\nexport function encodeTransactionAuthenticatorEd25519(signatureBytes: bytes, publicKeyBytes: bytes): TransactionAuthenticatorVariantEd25519 {\n  const ed25519PublicKey = new Ed25519PublicKey(publicKeyBytes)\n  const ed25519Signature = new Ed25519Signature(signatureBytes)\n  const authenticatorEd25519 = new TransactionAuthenticatorVariantEd25519(ed25519PublicKey, ed25519Signature)\n  return authenticatorEd25519;\n}\n\nexport function getEd25519SignMsgBytes(\n  signingMessage: SigningMessage,\n): bytes {\n  const hasher = createSigningMessageHasher();\n  const hashSeedBytes = hasher.get_salt();\n\n  const signingMessageBytes = (function () {\n    const se = new BcsSerializer();\n    signingMessage.serialize(se);\n    return se.getBytes();\n  })();\n\n  const msgBytes = ((a, b) => {\n    const tmp = new Uint8Array(a.length + b.length);\n    tmp.set(a, 0);\n    tmp.set(b, a.length);\n    return tmp;\n  })(hashSeedBytes, signingMessageBytes);\n\n  return msgBytes;\n}\n\n// simulate OneKeyConnect.starcoinSignMessage with the same response payload\nexport async function signMessage(msg: string, privateKeyHex: string): Promise<Record<string, string>> {\n  const msgBytes = new Uint8Array(Buffer.from(msg, 'utf8'))\n  const signingMessage = new SigningMessage(msgBytes);\n  const signingMessageBytes = getEd25519SignMsgBytes(signingMessage)\n  const publicKeyHex = await <string><unknown>ed.getPublicKey(stripHexPrefix(privateKeyHex));\n  const signatureBytes = await ed.sign(signingMessageBytes, stripHexPrefix(privateKeyHex))\n  const signatureHex = hexlify(signatureBytes)\n  return Promise.resolve({ publicKey: publicKeyHex, signature: signatureHex })\n}\n\nexport async function generateSignedMessage(signingMessage: SigningMessage, id: uint8, publicKeyHex: string, signatureHex: string): Promise<string> {\n  const publicKeyBytes = arrayify(addHexPrefix(publicKeyHex))\n  const addressHex = publicKeyToAddress(publicKeyHex)\n  const accountAddress = addressToSCS(addressHex)\n  const signatureBytes = arrayify(addHexPrefix(signatureHex))\n  const transactionAuthenticatorEd25519 = encodeTransactionAuthenticatorEd25519(signatureBytes, publicKeyBytes);\n  const chainId = new ChainId(id);\n  const signedMessage = new SignedMessage(accountAddress, signingMessage, transactionAuthenticatorEd25519, chainId)\n\n  const signedMessageBytes = bcsEncode(signedMessage);\n  const signedMessageHex = hexlify(signedMessageBytes);\n  return Promise.resolve(signedMessageHex);\n}\n\nexport async function encodeSignedMessage(msg: string, privateKeyBytes: bytes, chainId: uint8): Promise<string> {\n  const msgBytes = new Uint8Array(Buffer.from(msg, 'utf8'))\n  const signingMessage = new SigningMessage(msgBytes);\n  const { publicKey, signature } = await signMessage(msg, hexlify(privateKeyBytes))\n\n  const signedMessageHex = await generateSignedMessage(signingMessage, chainId, publicKey, signature)\n  return Promise.resolve(signedMessageHex);\n}\n\nexport function decodeSignedMessage(\n  data: BytesLike\n): SignedMessage {\n  const dataBytes = arrayify(data);\n  const scsData = (function () {\n    const de = new BcsDeserializer(dataBytes);\n    return SignedMessage.deserialize(de);\n  })();\n  return scsData;\n}\n\nexport async function recoverSignedMessageAddress(signedMessageHex: string): Promise<string> {\n  const signedMessage = decodeSignedMessage(signedMessageHex)\n\n  // const rawMessageBytes = signedMessage.message.message\n  // const rawMessageHex = hexlify(rawMessageBytes)\n  // const rawMessage = Buffer.from(stripHexPrefix(rawMessageHex), 'hex').toString('utf8')\n\n  let address\n\n  if (signedMessage.authenticator instanceof TransactionAuthenticatorVariantEd25519) {\n    const signatureBytes = signedMessage.authenticator.signature.value;\n    const msgBytes = getEd25519SignMsgBytes(signedMessage.message);\n    const publicKeyBytes = signedMessage.authenticator.public_key.value;\n    address = publicKeyToAddress(hexlify(publicKeyBytes));\n    const isSigned = await ed.verify(signatureBytes, msgBytes, publicKeyBytes);\n    if (!isSigned) {\n      throw new Error('Failed verify signature and message')\n    }\n    const isOk = checkAccount(publicKeyBytes, signedMessage.account)\n    if (!isOk) {\n      throw new Error('Failed: address are not match')\n    }\n  }\n  return Promise.resolve(address)\n}\n\n// TODO: check onchain authkey using chain_id\nfunction checkAccount(publicKeyBytes: bytes, accountAddress: AccountAddress): boolean {\n  const address = publicKeyToAddress(hexlify(publicKeyBytes));\n  if (address === addressFromSCS(accountAddress)) {\n    return true;\n  }\n  return false;\n}",
    "import { Logger } from '@ethersproject/logger';\n\nimport { version } from '../version';\n\nimport { Network, Networkish } from './types';\n\nexport { Network, Networkish };\nconst logger = new Logger(version);\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\ninterface Renetworkable extends DefaultProviderFunc {\n  renetwork: (network: Network) => DefaultProviderFunc;\n}\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n  return value && typeof value.renetwork === 'function';\n}\n\nfunction stcDefaultProvider(network: string | Network): Renetworkable {\n  const func = function (providers: any, options?: any): any {\n    if (providers.JsonRpcProvider) {\n      return new providers.JsonRpcProvider(options.jsonrpc, network);\n    }\n\n    return null;\n  };\n\n  func.renetwork = function (network: Network) {\n    return stcDefaultProvider(network);\n  };\n\n  return func;\n}\n\nconst STANDARD_NETWORKS: { [name: string]: Network } = {\n  test: {\n    chainId: 255,\n    name: 'test',\n    _defaultProvider: stcDefaultProvider('test'),\n  },\n  dev: {\n    chainId: 254,\n    name: 'dev',\n  },\n  barnard: {\n    chainId: 251,\n    name: 'barnard',\n  },\n  halley: {\n    chainId: 3,\n    name: 'halley',\n  },\n  proxima: {\n    chainId: 2,\n    name: 'proxima',\n  },\n  main: {\n    chainId: 1,\n    name: 'main',\n  },\n};\nexport function getNetwork(network: Networkish): Network {\n  if (network == null) {\n    return null;\n  }\n  if (typeof network === 'number') {\n    for (const name in STANDARD_NETWORKS) {\n      const standard = STANDARD_NETWORKS[name];\n      if (standard.chainId == network) {\n        return {\n          name: standard.name,\n          chainId: standard.chainId,\n          _defaultProvider: standard._defaultProvider || null,\n        };\n      }\n    }\n    return {\n      chainId: network,\n      name: 'unknown',\n    };\n  } else if (typeof network === 'string') {\n    const standard = STANDARD_NETWORKS[network];\n    if (standard == null) {\n      return null;\n    }\n    return {\n      name: standard.name,\n      chainId: standard.chainId,\n      _defaultProvider: standard._defaultProvider || null,\n    };\n  } else {\n    const standard = STANDARD_NETWORKS[network.name];\n    if (!standard) {\n      if (typeof network.chainId !== 'number') {\n        logger.throwArgumentError(\n          'invalid network chainId',\n          'network',\n          network\n        );\n      }\n      return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== standard.chainId) {\n      logger.throwArgumentError('network chainId mismatch', 'network', network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n      if (isRenetworkable(standard._defaultProvider)) {\n        defaultProvider = standard._defaultProvider.renetwork(network);\n      } else {\n        defaultProvider = standard._defaultProvider;\n      }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n      name: network.name,\n      chainId: standard.chainId,\n      _defaultProvider: defaultProvider,\n    };\n  }\n}\n",
    "import { Logger } from '@ethersproject/logger';\nimport { Deferrable, defineReadOnly } from '@ethersproject/properties';\nimport { OnceBlockable } from '@ethersproject/web';\n\nimport { Network } from '../networks';\nimport {\n  AccountAddress,\n  BlockTag,\n  BlockWithTransactions,\n  CallRequest,\n  EventFilter,\n  Filter,\n  formatStructTag,\n  HashValue,\n  ModuleId,\n  MoveStruct,\n  MoveValue,\n  StructTag,\n  TransactionEventView,\n  TransactionInfoView,\n  TransactionOutput,\n  TransactionRequest,\n  TransactionResponse,\n  U128,\n  U64,\n} from '../types';\nimport { parseTypeTag } from '../utils/parser';\n\nconst version = 'abstract-provider/5.0.5';\nconst logger = new Logger(version);\n\nexport type EventType = string | Array<string> | EventFilter;\n\nexport type Listener = (...args: any[]) => void;\n\n/// ////////////////////////////\n\n// Exported Abstracts\n\nexport abstract class Provider implements OnceBlockable {\n  // Network\n  abstract getNetwork(): Promise<Network>;\n\n  // Latest State\n  abstract getBlockNumber(): Promise<number>;\n\n  abstract getGasPrice(): Promise<U64>;\n\n  // Account\n\n  // eslint-disable-next-line consistent-return\n  async getBalance(\n    address: AccountAddress | Promise<AccountAddress>,\n    // token name, default to 0x1::STC::STC\n    token?: string,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<U128 | undefined> {\n    if (token === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      token = '0x1::STC::STC';\n    }\n    const resource = await this.getResource(\n      address,\n      `0x1::Account::Balance<${token}>`,\n      blockTag\n    );\n    if (resource !== undefined) {\n      return ((resource as MoveStruct).token as MoveStruct).value as U128;\n    }\n  }\n\n  // get all token balances of `address`.\n  async getBalances(\n    address: AccountAddress | Promise<AccountAddress>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<{ [k: string]: U128 } | undefined> {\n    const resources = await this.getResources(address, blockTag);\n    if (resources === undefined) {\n      return;\n    }\n    let tokenBalances = {};\n    // @ts-ignore\n    for (let k in resources) {\n      let typeTag = parseTypeTag(k);\n\n      // filter out balance resources.\n      // @ts-ignore\n      if (typeof typeTag === 'object' && typeTag.Struct !== undefined) {\n        // @ts-ignore\n        let structTag: StructTag = typeTag.Struct;\n        if (structTag.module === 'Account' && structTag.name === 'Balance') {\n          // @ts-ignore\n          let tokenStruct = formatStructTag(\n            structTag.type_params[0]['Struct'] as StructTag\n          );\n          tokenBalances[tokenStruct] = (resources[k].token as MoveStruct)\n            .value as U128;\n        }\n      }\n    }\n    return tokenBalances;\n  }\n\n  // eslint-disable-next-line consistent-return\n  async getSequenceNumber(\n    address: AccountAddress | Promise<AccountAddress>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<U64 | undefined> {\n    const resource = await this.getResource(\n      address,\n      '0x1::Account::Account',\n      blockTag\n    );\n    if (resource !== undefined) {\n      return resource.sequence_number as number;\n    }\n  }\n\n  // get Code of moduleId\n  abstract getCode(\n    moduleId: ModuleId | Promise<ModuleId>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<string | undefined>;\n\n  // get resource data.\n  abstract getResource(\n    address: AccountAddress | Promise<AccountAddress>,\n    resource_struct_tag: string | Promise<string>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<MoveStruct | undefined>;\n\n  // get all resources under `address`.\n  abstract getResources(\n    address: AccountAddress | Promise<AccountAddress>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<{ [k: string]: MoveStruct }>;\n\n  // Execution\n  abstract sendTransaction(\n    signedTransaction: string | Promise<string>\n  ): Promise<TransactionResponse>;\n\n  abstract call(\n    transaction: CallRequest | Promise<CallRequest>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<Array<MoveValue>>;\n\n  abstract dryRun(\n    transaction: Deferrable<TransactionRequest>\n  ): Promise<TransactionOutput>;\n\n  // Queries\n  abstract getBlock(\n    blockHashOrBlockTag: BlockTag | Promise<BlockTag>\n  ): Promise<BlockWithTransactions>;\n\n  // abstract getBlockWithTransactions(\n  //   blockHashOrBlockTag: BlockTag | Promise<BlockTag>\n  // ): Promise<BlockWithTransactions>;\n  abstract getTransaction(\n    transactionHash: HashValue\n  ): Promise<TransactionResponse>;\n\n  abstract getTransactionInfo(\n    transactionHash: HashValue\n  ): Promise<TransactionInfoView>;\n\n  abstract getEventsOfTransaction(\n    transactionHash: HashValue\n  ): Promise<TransactionEventView[]>;\n\n  // Bloom-filter Queries\n  abstract getTransactionEvents(\n    filter: Filter\n  ): Promise<Array<TransactionEventView>>;\n\n  // Event Emitter (ish)\n  abstract on(eventName: EventType, listener: Listener): Provider;\n\n  abstract once(eventName: EventType, listener: Listener): Provider;\n\n  abstract emit(eventName: EventType, ...args: Array<any>): boolean;\n\n  abstract listenerCount(eventName?: EventType): number;\n\n  abstract listeners(eventName?: EventType): Array<Listener>;\n\n  abstract off(eventName: EventType, listener?: Listener): Provider;\n\n  abstract removeAllListeners(eventName?: EventType): Provider;\n\n  // Alias for \"on\"\n  addListener(eventName: EventType, listener: Listener): Provider {\n    return this.on(eventName, listener);\n  }\n\n  // Alias for \"off\"\n  removeListener(eventName: EventType, listener: Listener): Provider {\n    return this.off(eventName, listener);\n  }\n\n  // @TODO: This *could* be implemented here, but would pull in events...\n  abstract waitForTransaction(\n    transactionHash: string,\n    confirmations?: number,\n    timeout?: number\n  ): Promise<TransactionInfoView>;\n\n  readonly _isProvider!: boolean;\n\n  constructor() {\n    logger.checkAbstract(new.target, Provider);\n    defineReadOnly(this, '_isProvider', true);\n  }\n\n  static isProvider(value: any): value is Provider {\n    // eslint-disable-next-line no-underscore-dangle\n    return !!(value && value._isProvider);\n  }\n}\n",
    "import { BigNumber } from '@ethersproject/bignumber';\nimport {\n  BytesLike,\n  hexDataLength,\n  hexValue,\n  isHexString\n} from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport { shallowCopy } from '@ethersproject/properties';\nimport { addHexPrefix } from 'ethereumjs-util';\n\nimport {\n  TransactionAuthenticator,\n  TransactionVMStatus_Executed,\n  TransactionVMStatus_MiscellaneousError,\n  TransactionVMStatus_OutOfGas,\n  TransactionVMStatus,\n  TypeTag,\n  U128,\n  U256,\n  U64,\n  U8,\n  AnnotatedMoveValue,\n  MoveValue, AnnotatedMoveStruct, MoveStruct,\n  BlockMetadataView,\n  BlockView,\n  BlockWithTransactions,\n  BlockWithTxnHashes,\n  Filter,\n  TransactionEventView,\n  TransactionInfoView, TransactionOutput,\n  TransactionResponse, TransactionWriteAction,\n  RawUserTransactionView, SignedUserTransactionView\n\n} from '../types';\nimport { version } from '../version';\nimport { decodeSignedUserTransaction } from '../encoding';\n\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [key: string]: FormatFunc };\n\nexport type Formats = {\n  blockMetadata: FormatFuncs;\n  rawTransaction: FormatFuncs;\n  signedUserTransaction: FormatFuncs;\n  transaction: FormatFuncs;\n\n  // transactionRequest: FormatFuncs;\n  transactionInfo: FormatFuncs;\n  transactionEvent: FormatFuncs;\n  eventFilter: FormatFuncs;\n  transactionOutput: FormatFuncs;\n\n  blockHeader: FormatFuncs;\n  blockBody: FormatFuncs;\n  block: FormatFuncs;\n  blockWithTransactions: FormatFuncs;\n};\n\nexport function formatMoveStruct(v: AnnotatedMoveStruct): MoveStruct {\n  // eslint-disable-next-line unicorn/no-reduce\n  return v.value.reduce(\n    (o, [k, field]) => ({ ...o, [k]: formatMoveValue(field) }),\n    {}\n  );\n}\n\nexport function formatMoveValue(v: AnnotatedMoveValue): MoveValue {\n  if ('Bool' in v) {\n    return v.Bool;\n  }\n  if ('U8' in v) {\n    return v.U8;\n  }\n  if ('U64' in v) {\n    return Formatter.bigint(v.U64);\n  }\n  if ('U128' in v) {\n    return Formatter.bigint(v.U128);\n  }\n  if ('Address' in v) {\n    return v.Address;\n  }\n  if ('Bytes' in v) {\n    return hexValue(v.Bytes);\n  }\n  if ('Vector' in v) {\n    return v.Vector.map((elem) => formatMoveValue(elem));\n  }\n  if ('Struct' in v) {\n    const struct = v.Struct;\n    // eslint-disable-next-line unicorn/no-reduce\n    return struct.value.reduce(\n      (o, [k, field]) => ({ ...o, [k]: formatMoveValue(field) }),\n      {}\n    );\n  }\n  throw new Error(`invalid annotated move value, ${JSON.stringify(v)}`);\n\n}\n\nexport class Formatter {\n  readonly formats: Formats;\n\n  constructor() {\n    logger.checkNew(new.target, Formatter);\n    this.formats = this.getDefaultFormats();\n  }\n\n  getDefaultFormats(): Formats {\n    const formats: Formats = <Formats>{};\n\n    const address = this.address.bind(this);\n    const bigNumber = this.bigNumber.bind(this);\n    const blockTag = this.blockTag.bind(this);\n    const data = this.data.bind(this);\n    const hash = this.hash.bind(this);\n    const hex = this.hex.bind(this);\n    const number = this.number.bind(this);\n    const u64 = this.u64.bind(this);\n    // eslint-disable-next-line no-underscore-dangle\n    const i64 = Formatter.bigint.bind(this);\n    const u8 = this.u8.bind(this);\n    const u256 = this.u256.bind(this);\n\n    const strictData = (v: any) => {\n      return this.data(v, true);\n    };\n\n    formats.rawTransaction = {\n      sender: address,\n      sequence_number: u64,\n      payload: data,\n      max_gas_amount: u64,\n      gas_unit_price: u64,\n      gas_token_code: (v) => v,\n      expiration_timestamp_secs: u64,\n      chain_id: u8\n    };\n\n    formats.signedUserTransaction = {\n      transaction_hash: hash,\n      raw_txn: this.rawUserTransaction.bind(this),\n      authenticator: this.transactionAuthenticator.bind(this)\n    };\n\n    formats.blockMetadata = {\n      parent_hash: hash,\n      timestamp: u64,\n      author: address,\n      author_auth_key: hex,\n      uncles: u64,\n      number: u64,\n      chain_id: u8,\n      parent_gas_used: u64\n    };\n\n    const txnBlockInfo = {\n      block_hash: Formatter.allowNull(hash),\n      block_number: Formatter.allowNull(u64),\n      transaction_hash: Formatter.allowNull(hash,),\n      transaction_index: Formatter.allowNull(number)\n    };\n\n    formats.transaction = {\n      block_metadata: Formatter.allowNull(this.blockMetadata.bind(this), null),\n      user_transaction: Formatter.allowNull(\n        this.signedUserTransaction.bind(this),\n        null\n      ),\n      ...txnBlockInfo\n    };\n    formats.blockBody = {\n      Full: Formatter.allowNull(\n        Formatter.arrayOf(this.signedUserTransaction.bind(this))\n      ),\n      Hashes: Formatter.allowNull(Formatter.arrayOf(hash))\n    };\n    formats.blockHeader = {\n      block_hash: hash,\n\n      parent_hash: hash,\n      timestamp: u64,\n      number: u64,\n      author: address,\n      author_auth_key: Formatter.allowNull(hex, null),\n      /// The transaction accumulator root hash after executing this block.\n      txn_accumulator_root: hash,\n      /// The parent block accumulator root hash.\n      block_accumulator_root: hash,\n      /// The last transaction state_root of this block after execute.\n      state_root: hash,\n      /// Gas used for contracts execution.\n      gas_used: u64,\n      /// Block difficulty\n      difficulty: u256,\n      /// Consensus nonce field.\n      nonce: u64,\n      /// hash for block body\n      body_hash: hash,\n      /// The chain id\n      chain_id: u8\n    };\n\n    formats.blockWithTransactions = {\n      header: (value) => Formatter.check(formats.blockHeader, value),\n      body: (value) => value\n    };\n    formats.block = {\n      header: (value) => Formatter.check(formats.blockHeader, value),\n      body: (value) => Formatter.check(formats.blockBody, value),\n      confirmations: number\n    };\n\n    formats.transactionInfo = {\n      state_root_hash: hash,\n      event_root_hash: hash,\n      gas_used: u64,\n      status: this.transactionVmStatus.bind(this),\n      txn_events: Formatter.allowNull(\n        Formatter.arrayOf(this.transactionEvent.bind(this)),\n        null\n      ),\n      ...txnBlockInfo\n    };\n\n    formats.transactionEvent = {\n      data: hex,\n      type_tags: this.typeTag.bind(this),\n      event_key: hex,\n      event_seq_number: u64,\n      ...txnBlockInfo\n    };\n\n    formats.transactionOutput = {\n      gas_used: u64,\n      status: this.transactionVmStatus.bind(this),\n      events: Formatter.allowNull(Formatter.arrayOf(this.transactionEvent.bind(this))),\n      write_set: Formatter.allowNull(Formatter.arrayOf(this.transactionWriteAction.bind(this)))\n    };\n\n    formats.blockWithTransactions = shallowCopy(formats.block);\n    formats.blockWithTransactions.transactions = Formatter.allowNull(\n      Formatter.arrayOf(this.transactionResponse.bind(this))\n    );\n\n    formats.eventFilter = {\n      from_block: Formatter.allowNull(blockTag),\n      to_block: Formatter.allowNull(blockTag),\n      event_keys: Formatter.arrayOf(hex),\n      limit: Formatter.allowNull(number)\n    };\n\n    return formats;\n  }\n\n  typeTag(value: any): TypeTag {\n    return value as TypeTag;\n  }\n\n  moveValue(value: AnnotatedMoveValue): MoveValue {\n    return formatMoveValue(value);\n  }\n\n  moveStruct(value: AnnotatedMoveStruct): MoveStruct {\n    return formatMoveStruct(value);\n  }\n\n  transactionAuthenticator(value: any): TransactionAuthenticator {\n    return value as TransactionAuthenticator;\n  }\n\n  rawUserTransaction(value: any): RawUserTransactionView {\n    return Formatter.check(this.formats.rawTransaction, value);\n  }\n\n  signedUserTransaction(value: any): SignedUserTransactionView {\n    return Formatter.check(this.formats.signedUserTransaction, value);\n  }\n\n  blockMetadata(value: any): BlockMetadataView {\n    return Formatter.check(this.formats.blockMetadata, value);\n  }\n\n  transactionOutput(value: any): TransactionOutput {\n    return Formatter.check(this.formats.transactionOutput, value);\n  }\n\n  transactionWriteAction(value: any): TransactionWriteAction {\n    return value as TransactionWriteAction;\n  }\n\n  transactionEvent(value: any): TransactionEventView {\n    return Formatter.check(this.formats.transactionEvent, value);\n  }\n\n  transactionVmStatus(value: any): TransactionVMStatus {\n    if (typeof value === 'string') {\n      if (\n        [\n          TransactionVMStatus_Executed,\n          TransactionVMStatus_OutOfGas,\n          TransactionVMStatus_MiscellaneousError\n        ].includes(value)\n      ) {\n        return value as TransactionVMStatus;\n      }\n\n      throw new Error(`invalid txn vm_status: ${value}`);\n    } else if (typeof value === 'object') {\n      if (value.MoveAbort) {\n        return {\n          MoveAbort: {\n            location: value.MoveAbort.location,\n            abort_code: this.u64(value.MoveAbort.abort_code)\n          }\n        };\n      }\n      if (value.ExecutionFailure) {\n        return value as TransactionVMStatus;\n      }\n      if (value.Discard) {\n        return {\n          Discard: {\n            status_code: this.u64(value.Discard.status_code)\n          }\n        };\n      }\n      throw new Error(`invalid txn vm_status: ${JSON.stringify(value)}`);\n    } else {\n      throw new TypeError(`invalid txn vm_status type ${value}`);\n    }\n  }\n\n  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n  // Strict! Used on input.\n  number(number: any): number {\n    if (number === '0x') {\n      return 0;\n    }\n    return BigNumber.from(number).toNumber();\n  }\n\n  u8(value: any): U8 {\n    if (typeof value === 'string') {\n      return Number.parseInt(value, 10);\n    } if (typeof value === 'number') {\n      return value;\n    }\n    throw new Error(`invalid u8: ${value}`);\n  }\n\n  u64(number: any): U64 {\n    return Formatter.bigint(number);\n  }\n\n  u128(number: any): U128 {\n    return Formatter.bigint(number);\n  }\n\n  u256(number: any): U256 {\n    if (typeof number === 'string') {\n      return number;\n    }\n    if (typeof number === 'number') {\n      return number.toString();\n    }\n    throw new Error(`invalid bigint: ${number}`);\n  }\n\n  static bigint(number: any): number | bigint {\n    if (typeof number === 'string') {\n      const bn = BigInt(number);\n      if (bn > Number.MAX_SAFE_INTEGER) {\n        return bn;\n      }\n      // eslint-disable-next-line radix\n      return Number.parseInt(number);\n\n    }\n    if (typeof number === 'number') {\n      return number;\n    }\n    throw new TypeError(`invalid bigint: ${number}`);\n  }\n\n  // Strict! Used on input.\n  bigNumber(value: any): BigNumber {\n    return BigNumber.from(value);\n  }\n\n  // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n  boolean(value: any): boolean {\n    if (typeof value === 'boolean') {\n      return value;\n    }\n    if (typeof value === 'string') {\n      value = value.toLowerCase();\n      if (value === 'true') {\n        return true;\n      }\n      if (value === 'false') {\n        return false;\n      }\n    }\n    throw new Error(`invalid boolean - ${value}`);\n  }\n\n  hex(value: any, strict?: boolean): string {\n    if (typeof value === 'string') {\n      if (!strict && value.slice(0, 2) !== '0x') {\n        value = `0x${value}`;\n      }\n      if (isHexString(value)) {\n        return value.toLowerCase();\n      }\n    }\n    return logger.throwArgumentError('invalid hex', 'value', value);\n  }\n\n  data(value: any, strict?: boolean): string {\n    const result = this.hex(value, strict);\n    if (result.length % 2 !== 0) {\n      throw new Error(`invalid data; odd-length - ${value}`);\n    }\n    return result;\n  }\n\n  // Requires an address\n  // Strict! Used on input.\n  address(value: any): string {\n    if (typeof value !== 'string') {\n      logger.throwArgumentError('invalid address', 'address', value);\n    }\n    const result = this.hex(value, true);\n    if (hexDataLength(result) !== 16) {\n      return logger.throwArgumentError('invalid address', 'value', value);\n    }\n    return addHexPrefix(value);\n  }\n\n  // Strict! Used on input.\n  blockTag(blockTag: any): number {\n    // if (blockTag == null) {\n    //   return 'latest';\n    // }\n\n    if (blockTag === 'earliest') {\n      return 0;\n    }\n\n    // if (blockTag === 'latest' || blockTag === 'pending') {\n    //   return blockTag;\n    // }\n\n    if (typeof blockTag === 'number') {\n      return blockTag;\n    }\n\n    throw new Error('invalid blockTag');\n  }\n\n  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n  hash(value: any, strict?: boolean): string {\n    const result = this.hex(value, strict);\n    if (hexDataLength(result) !== 32) {\n      return logger.throwArgumentError('invalid hash', 'value', value);\n    }\n    return result;\n  }\n\n  // // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n  // difficulty(value: any): number {\n  //   if (value == null) {\n  //     return null;\n  //   }\n  //\n  //   const v = BigNumber.from(value);\n  //\n  //   try {\n  //     return v.toNumber();\n  //     // eslint-disable-next-line no-empty\n  //   } catch (error) {}\n  //\n  //   return null;\n  // }\n\n  // uint256(value: any): string {\n  //   if (!isHexString(value)) {\n  //     throw new Error('invalid uint256');\n  //   }\n  //   return hexZeroPad(value, 32);\n  // }\n\n  private _block(value: any): BlockView {\n    const block = Formatter.check(this.formats.block, value);\n\n    const transactions = block.body.Full ? block.body.Full : block.body.Hashes;\n    return {\n      header: block.header,\n      transactions,\n      confirmations: block.confirmations\n    };\n  }\n\n  blockWithTxnHashes(value: any): BlockWithTxnHashes {\n    const { header, transactions, confirmations } = this._block(value);\n    return {\n      header,\n      transactions: (transactions as SignedUserTransactionView[]).map(\n        (t) => t.transaction_hash\n      ),\n      confirmations\n    };\n  }\n\n  blockWithTransactions(value: any): BlockWithTransactions {\n    const { header, transactions, confirmations } = this._block(value);\n    return {\n      header,\n      transactions: transactions as Array<SignedUserTransactionView>,\n      confirmations\n    };\n  }\n\n  // // Strict! Used on input.\n  // transactionRequest(value: any): any {\n  //   return Formatter.check(this.formats.transactionRequest, value);\n  // }\n\n  transactionResponse(transaction: any): TransactionResponse {\n    return transaction as TransactionResponse;\n  }\n\n  // transactionResponse(transaction: any): TransactionResponse {\n  //   // Rename gas to gasLimit\n  //   if (transaction.gas != null && transaction.gasLimit == null) {\n  //     transaction.gasLimit = transaction.gas;\n  //   }\n  //\n  //   // Some clients (TestRPC) do strange things like return 0x0 for the\n  //   // 0 address; correct this to be a real address\n  //   if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n  //     transaction.to = '0x0000000000000000000000000000000000000000';\n  //   }\n  //\n  //   // Rename input to data\n  //   if (transaction.input != null && transaction.data == null) {\n  //     transaction.data = transaction.input;\n  //   }\n  //\n  //   // If to and creates are empty, populate the creates from the transaction\n  //   if (transaction.to == null && transaction.creates == null) {\n  //     transaction.creates = this.contractAddress(transaction);\n  //   }\n  //\n  //   // @TODO: use transaction.serialize? Have to add support for including v, r, and s...\n  //   /*\n  //   if (!transaction.raw) {\n  //\n  //        // Very loose providers (e.g. TestRPC) do not provide a signature or raw\n  //        if (transaction.v && transaction.r && transaction.s) {\n  //            let raw = [\n  //                stripZeros(hexlify(transaction.nonce)),\n  //                stripZeros(hexlify(transaction.gasPrice)),\n  //                stripZeros(hexlify(transaction.gasLimit)),\n  //                (transaction.to || \"0x\"),\n  //                stripZeros(hexlify(transaction.value || \"0x\")),\n  //                hexlify(transaction.data || \"0x\"),\n  //                stripZeros(hexlify(transaction.v || \"0x\")),\n  //                stripZeros(hexlify(transaction.r)),\n  //                stripZeros(hexlify(transaction.s)),\n  //            ];\n  //\n  //            transaction.raw = rlpEncode(raw);\n  //        }\n  //    }\n  //    */\n  //\n  //   const result: TransactionResponse = Formatter.check(\n  //     this.formats.transaction,\n  //     transaction\n  //   );\n  //\n  //   if (transaction.chainId != null) {\n  //     let chainId = transaction.chainId;\n  //\n  //     if (isHexString(chainId)) {\n  //       chainId = BigNumber.from(chainId).toNumber();\n  //     }\n  //\n  //     result.chainId = chainId;\n  //   } else {\n  //     let chainId = transaction.networkId;\n  //\n  //     // geth-etc returns chainId\n  //     if (chainId == null && result.v == null) {\n  //       chainId = transaction.chainId;\n  //     }\n  //\n  //     if (isHexString(chainId)) {\n  //       chainId = BigNumber.from(chainId).toNumber();\n  //     }\n  //\n  //     if (typeof chainId !== 'number' && result.v != null) {\n  //       chainId = (result.v - 35) / 2;\n  //       if (chainId < 0) {\n  //         chainId = 0;\n  //       }\n  //       chainId = parseInt(chainId);\n  //     }\n  //\n  //     if (typeof chainId !== 'number') {\n  //       chainId = 0;\n  //     }\n  //\n  //     result.chainId = chainId;\n  //   }\n  //\n  //   // 0x0000... should actually be null\n  //   if (result.blockHash && result.blockHash.replace(/0/g, '') === 'x') {\n  //     result.blockHash = null;\n  //   }\n  //\n  //   return result;\n  // }\n\n  userTransactionData(value: BytesLike): SignedUserTransactionView {\n    return decodeSignedUserTransaction(value);\n  }\n\n  transactionInfo(value: any): TransactionInfoView {\n    return Formatter.check(this.formats.transactionInfo, value);\n  }\n\n  topics(value: any): any {\n    if (Array.isArray(value)) {\n      return value.map((v) => this.topics(v));\n    } if (value != undefined) {\n      return this.hash(value, true);\n    }\n\n    return null;\n  }\n\n  filter(value: any): Filter {\n    return Formatter.check(this.formats.eventFilter, value);\n  }\n\n  static check(format: { [name: string]: FormatFunc }, object: any): any {\n    const result: any = {};\n    for (const key in format) {\n      try {\n        const value = format[key](object[key]);\n        if (value !== undefined) {\n          result[key] = value;\n        }\n      } catch (error) {\n        error.checkKey = key;\n        error.checkValue = object[key];\n        throw error;\n      }\n    }\n    return result;\n  }\n\n  // if value is null-ish, nullValue is returned\n  static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n    return function (value: any) {\n      if (value == undefined) {\n        return nullValue;\n      }\n      return format(value);\n    };\n  }\n\n  // If value is false-ish, replaceValue is returned\n  static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n    return function (value: any) {\n      if (!value) {\n        return replaceValue;\n      }\n      return format(value);\n    };\n  }\n\n  // Requires an Array satisfying check\n  static arrayOf(format: FormatFunc): FormatFunc {\n    return function (array: any): Array<any> {\n      if (!Array.isArray(array)) {\n        throw new TypeError('not an array');\n      }\n\n      const result: any = [];\n\n      array.forEach(function (value) {\n        result.push(format(value));\n      });\n\n      return result;\n    };\n  }\n\n\n}\n\n//\n// export interface CommunityResourcable {\n//   isCommunityResource(): boolean;\n// }\n//\n// export function isCommunityResourcable(\n//   value: any\n// ): value is CommunityResourcable {\n//   return value && typeof value.isCommunityResource === 'function';\n// }\n//\n// export function isCommunityResource(value: any): boolean {\n//   return isCommunityResourcable(value) && value.isCommunityResource();\n// }\n",
    "// import { clearInterval, clearTimeout, setInterval, setTimeout } from 'timers';\n\n// eslint-disable-next-line max-classes-per-file\nimport { Base58 } from '@ethersproject/basex';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  concat,\n  hexDataLength,\n  hexDataSlice,\n  hexlify,\n  hexZeroPad,\n  isHexString,\n} from '@ethersproject/bytes';\nimport { Logger } from '@ethersproject/logger';\nimport {\n  Deferrable,\n  defineReadOnly,\n  resolveProperties,\n} from '@ethersproject/properties';\nimport { sha256 } from '@ethersproject/sha2';\nimport { poll } from '@ethersproject/web';\nimport { EventType, Listener, Provider } from '../abstract-provider';\nimport { getNetwork, Network, Networkish } from '../networks';\nimport { version } from '../version';\n\nimport { Formatter } from './formatter';\nimport {\n  ModuleId,\n  AccountAddress,\n  BlockNumber,\n  MoveStruct,\n  MoveValue,\n  TransactionEventView,\n  BlockTag,\n  BlockView,\n  BlockWithTransactions,\n  CallRequest,\n  Filter,\n  TransactionInfoView,\n  TransactionOutput,\n  TransactionRequest,\n  TransactionResponse,\n  U64,\n  SignedUserTransactionView,\n  AnnotatedMoveStruct,\n  formatFunctionId,\n  HashValue,\n} from '../types';\n\nconst logger = new Logger(version);\n\n// Event Serializing\nfunction serializeTopics(eventKeys?: Array<string>): string {\n  if (eventKeys === undefined || eventKeys.length === 0) {\n    return '*';\n  } else {\n    return eventKeys.join('|');\n  }\n}\n\nfunction deserializeTopics(data: string): Array<string> {\n  if (data === '') {\n    return [];\n  }\n  if (data === '*') {\n    return [];\n  }\n\n  return data.split('|');\n}\n\nfunction getEventTag(eventName: EventType): string {\n  if (typeof eventName === 'string') {\n    eventName = eventName.toLowerCase();\n\n    if (hexDataLength(eventName) === 32) {\n      return 'tx:' + eventName;\n    }\n\n    if (eventName.indexOf(':') === -1) {\n      return eventName;\n    }\n  } else if (Array.isArray(eventName)) {\n    return 'filter:' + serializeTopics(eventName);\n  } else if (typeof eventName === 'object') {\n    return 'filter:' + serializeTopics(eventName.event_keys);\n  }\n\n  throw new Error('invalid event - ' + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n  return new Date().getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, duration);\n  });\n}\n\n//////////////////////////////\n// Provider Object\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nexport const CONSTANTS = {\n  pending: 'pending',\n  block: 'block',\n  network: 'network',\n  poll: 'poll',\n  filter: 'filter',\n  tx: 'tx',\n};\n\nconst PollableEvents = [\n  CONSTANTS.pending,\n  CONSTANTS.block,\n  CONSTANTS.network,\n  CONSTANTS.poll,\n];\n\nexport class Event {\n  readonly listener!: Listener;\n  readonly once!: boolean;\n  readonly tag!: string;\n\n  constructor(tag: string, listener: Listener, once: boolean) {\n    defineReadOnly(this, 'tag', tag);\n    defineReadOnly(this, 'listener', listener);\n    defineReadOnly(this, 'once', once);\n  }\n\n  get event(): EventType {\n    switch (this.type) {\n      case 'tx':\n        return this.hash;\n      case 'filter':\n        return this.filter;\n    }\n    return this.tag;\n  }\n\n  get type(): string {\n    return this.tag.split(':')[0];\n  }\n\n  get hash(): string {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'tx') {\n      // @ts-ignore\n      return null;\n    }\n    return comps[1];\n  }\n\n  get filter(): Filter {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'filter') {\n      // @ts-ignore\n      return null;\n    }\n    const topics = deserializeTopics(comps[1]);\n    const filter: Filter = {};\n\n    if (topics.length > 0) {\n      filter.event_keys = topics;\n    }\n\n    return filter;\n  }\n\n  pollable(): boolean {\n    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\nfunction bytes32ify(value: number): string {\n  return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\nfunction base58Encode(data: Uint8Array): string {\n  return Base58.encode(\n    concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)])\n  );\n}\n\nexport const RPC_ACTION = {\n  getChainInfo: 'getChainInfo',\n  getNodeInfo: 'getNodeInfo',\n  sendTransaction: 'sendTransaction',\n  getBlock: 'getBlock',\n  getTransactionByHash: 'getTransactionByHash',\n  getTransactionInfo: 'getTransactionInfo',\n  getEventsOfTransaction: 'getEventsOfTransaction',\n  getEvents: 'getEvents',\n  call: 'call',\n  callV2: 'callV2',\n  getCode: 'getCode',\n  getResource: 'getResource',\n  getAccountState: 'getAccountState',\n  getGasPrice: 'getGasPrice',\n  dryRun: 'dryRun',\n  dryRunRaw: 'dryRunRaw',\n};\n\nlet defaultFormatter: Formatter;\n\nlet nextPollId = 1;\n\nexport abstract class BaseProvider extends Provider {\n  _networkPromise: Promise<Network>;\n\n  _network: Network;\n\n  _events: Array<Event>;\n\n  formatter: Formatter;\n\n  // To help mitigate the eventually consistent nature of the blockchain\n  // we keep a mapping of events we emit. If we emit an event X, we expect\n  // that a user should be able to query for that event in the callback,\n  // if the node returns null, we stall the response until we get back a\n  // meaningful value, since we may be hitting a re-org, or a node that\n  // has not indexed the event yet.\n  // Events:\n  //   - t:{hash}    - Transaction hash\n  //   - b:{hash}    - BlockHash\n  //   - block       - The most recent emitted block\n  _emitted: { [eventName: string]: number | 'pending' };\n\n  _pollingInterval: number;\n\n  _poller: NodeJS.Timer;\n\n  _bootstrapPoll: NodeJS.Timer;\n\n  _lastBlockNumber: number;\n\n  _fastBlockNumber: number;\n\n  _fastBlockNumberPromise: Promise<number>;\n\n  _fastQueryDate: number;\n\n  _maxInternalBlockNumber: number;\n\n  _internalBlockNumber: Promise<{\n    blockNumber: number;\n    reqTime: number;\n    respTime: number;\n  }>;\n\n  readonly anyNetwork: boolean;\n\n  /**\n   *  ready\n   *\n   *  A Promise<Network> that resolves only once the provider is ready.\n   *\n   *  Sub-classes that call the super with a network without a chainId\n   *  MUST set this. Standard named networks have a known chainId.\n   *\n   */\n\n  constructor(network: Networkish | Promise<Network>) {\n    logger.checkNew(new.target, Provider);\n\n    super();\n\n    // Events being listened to\n    this._events = [];\n\n    this._emitted = { block: -2 };\n\n    this.formatter = new.target.getFormatter();\n\n    // If network is any, this Provider allows the underlying\n    // network to change dynamically, and we auto-detect the\n    // current network\n    defineReadOnly(this, 'anyNetwork', network === 'any');\n    if (this.anyNetwork) {\n      network = this.detectNetwork();\n    }\n\n    if (network instanceof Promise) {\n      this._networkPromise = network;\n\n      // Squash any \"unhandled promise\" errors; that do not need to be handled\n      // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars\n      network.catch((error) => { });\n\n      // Trigger initial network setting (async)\n      // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars\n      this._ready().catch((error) => { });\n    } else {\n      const knownNetwork = getNetwork(network);\n      if (knownNetwork) {\n        defineReadOnly(this, '_network', knownNetwork);\n        this.emit('network', knownNetwork, null);\n      } else {\n        logger.throwArgumentError('invalid network', 'network', network);\n      }\n    }\n\n    this._maxInternalBlockNumber = -1024;\n\n    this._lastBlockNumber = -2;\n\n    this._pollingInterval = 4000;\n\n    this._fastQueryDate = 0;\n  }\n\n  async _ready(): Promise<Network> {\n    if (this._network == null) {\n      let network: Network = null;\n      if (this._networkPromise) {\n        try {\n          network = await this._networkPromise;\n          // eslint-disable-next-line no-empty\n        } catch (error) { }\n      }\n\n      // Try the Provider's network detection (this MUST throw if it cannot)\n      if (network == null) {\n        network = await this.detectNetwork();\n      }\n\n      // This should never happen; every Provider sub-class should have\n      // suggested a network by here (or have thrown).\n      if (!network) {\n        logger.throwError(\n          'no network detected',\n          Logger.errors.UNKNOWN_ERROR,\n          {}\n        );\n      }\n\n      // Possible this call stacked so do not call defineReadOnly again\n      if (this._network == null) {\n        if (this.anyNetwork) {\n          this._network = network;\n        } else {\n          defineReadOnly(this, '_network', network);\n        }\n        this.emit('network', network, null);\n      }\n    }\n\n    return this._network;\n  }\n\n  // This will always return the most recently established network.\n  // For \"any\", this can change (a \"network\" event is emitted before\n  // any change is refelcted); otherwise this cannot change\n  get ready(): Promise<Network> {\n    return poll(() => {\n      return this._ready().then(\n        (network) => {\n          return network;\n        },\n        (error) => {\n          // If the network isn't running yet, we will wait\n          if (\n            error.code === Logger.errors.NETWORK_ERROR &&\n            error.event === 'noNetwork'\n          ) {\n            return undefined;\n          }\n          throw error;\n        }\n      );\n    });\n  }\n\n  // @TODO: Remove this and just create a singleton formatter\n  static getFormatter(): Formatter {\n    if (defaultFormatter == null) {\n      defaultFormatter = new Formatter();\n    }\n    return defaultFormatter;\n  }\n\n  // Fetches the blockNumber, but will reuse any result that is less\n  // than maxAge old or has been requested since the last request\n  private async _getInternalBlockNumber(maxAge: number): Promise<number> {\n    await this._ready();\n\n    const internalBlockNumber = this._internalBlockNumber;\n\n    if (maxAge > 0 && this._internalBlockNumber) {\n      const result = await internalBlockNumber;\n      if (getTime() - result.respTime <= maxAge) {\n        return result.blockNumber;\n      }\n    }\n\n    const reqTime = getTime();\n\n    const checkInternalBlockNumber = resolveProperties({\n      blockNumber: this.perform(RPC_ACTION.getChainInfo, {}).then(\n        (chainInfo) => chainInfo.head.number,\n        (err) => err\n      ),\n      networkError: this.getNetwork().then(\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        (network) => null,\n        (error) => error\n      ),\n    }).then(({ blockNumber, networkError }) => {\n      if (networkError) {\n        // Unremember this bad internal block number\n        if (this._internalBlockNumber === checkInternalBlockNumber) {\n          this._internalBlockNumber = null;\n        }\n        throw networkError;\n      }\n\n      const respTime = getTime();\n\n      blockNumber = BigNumber.from(blockNumber).toNumber();\n      if (blockNumber < this._maxInternalBlockNumber) {\n        blockNumber = this._maxInternalBlockNumber;\n      }\n\n      this._maxInternalBlockNumber = blockNumber;\n      this._setFastBlockNumber(blockNumber);\n      return { blockNumber, reqTime, respTime };\n    });\n\n    this._internalBlockNumber = checkInternalBlockNumber;\n\n    return (await checkInternalBlockNumber).blockNumber;\n  }\n\n  protected async poll(): Promise<void> {\n    const pollId = nextPollId++;\n\n    // Track all running promises, so we can trigger a post-poll once they are complete\n    const runners: Array<Promise<void>> = [];\n\n    const blockNumber = await this._getInternalBlockNumber(\n      100 + this.pollingInterval / 2\n    );\n    this._setFastBlockNumber(blockNumber);\n\n    // Emit a poll event after we have the latest (fast) block number\n    this.emit('poll', pollId, blockNumber);\n\n    // If the block has not changed, meh.\n    if (blockNumber === this._lastBlockNumber) {\n      this.emit('didPoll', pollId);\n      return;\n    }\n\n    // First polling cycle, trigger a \"block\" events\n    if (this._emitted.block === -2) {\n      this._emitted.block = blockNumber - 1;\n    }\n\n    if (Math.abs(<number>this._emitted.block - blockNumber) > 1000) {\n      logger.warn('network block skew detected; skipping block events');\n      this.emit(\n        'error',\n        logger.makeError(\n          'network block skew detected',\n          Logger.errors.NETWORK_ERROR,\n          {\n            blockNumber: blockNumber,\n            event: 'blockSkew',\n            previousBlockNumber: this._emitted.block,\n          }\n        )\n      );\n      this.emit(CONSTANTS.block, blockNumber);\n    } else {\n      // Notify all listener for each block that has passed\n      for (let i = <number>this._emitted.block + 1; i <= blockNumber; i++) {\n        this.emit(CONSTANTS.block, i);\n      }\n    }\n\n    // The emitted block was updated, check for obsolete events\n    if (<number>this._emitted.block !== blockNumber) {\n      this._emitted.block = blockNumber;\n\n      Object.keys(this._emitted).forEach((key) => {\n        // The block event does not expire\n        if (key === CONSTANTS.block) {\n          return;\n        }\n\n        // The block we were at when we emitted this event\n        const eventBlockNumber = this._emitted[key];\n\n        // We cannot garbage collect pending transactions or blocks here\n        // They should be garbage collected by the Provider when setting\n        // \"pending\" events\n        if (eventBlockNumber === 'pending') {\n          return;\n        }\n\n        // Evict any transaction hashes or block hashes over 12 blocks\n        // old, since they should not return null anyways\n        if (blockNumber - eventBlockNumber > 12) {\n          delete this._emitted[key];\n        }\n      });\n    }\n\n    // First polling cycle\n    if (this._lastBlockNumber === -2) {\n      this._lastBlockNumber = blockNumber - 1;\n    }\n\n    // Find all transaction hashes we are waiting on\n    this._events.forEach((event) => {\n      switch (event.type) {\n        case CONSTANTS.tx: {\n          const hash = event.hash;\n          const runner = this.getTransactionInfo(hash)\n            .then((receipt) => {\n              if (!receipt || receipt.block_number == null) {\n                return null;\n              }\n              this._emitted['t:' + hash] = receipt.block_number;\n              this.emit(hash, receipt);\n              return null;\n            })\n            .catch((error: Error) => {\n              this.emit('error', error);\n            });\n\n          runners.push(runner);\n\n          break;\n        }\n\n        case CONSTANTS.filter: {\n          const filter = event.filter;\n          filter.from_block = this._lastBlockNumber + 1;\n          filter.to_block = blockNumber;\n\n          const runner = this.getTransactionEvents(filter)\n            .then((logs) => {\n              if (logs.length === 0) {\n                return;\n              }\n              logs.forEach((log: TransactionEventView) => {\n                this._emitted['b:' + log.block_hash] = log.block_number;\n                this._emitted['t:' + log.transaction_hash] = log.block_number;\n                this.emit(filter, log);\n              });\n            })\n            .catch((error: Error) => {\n              this.emit('error', error);\n            });\n          runners.push(runner);\n\n          break;\n        }\n      }\n    });\n\n    this._lastBlockNumber = blockNumber;\n\n    // Once all events for this loop have been processed, emit \"didPoll\"\n    Promise.all(runners).then(() => {\n      this.emit('didPoll', pollId);\n    });\n\n    return null;\n  }\n\n  get network(): Network {\n    return this._network;\n  }\n\n  // This method should query the network if the underlying network\n  // can change, such as when connected to a JSON-RPC backend\n  abstract detectNetwork(): Promise<Network>;\n\n  async getNetwork(): Promise<Network> {\n    const network = await this._ready();\n\n    // Make sure we are still connected to the same network; this is\n    // only an external call for backends which can have the underlying\n    // network change spontaneously\n    const currentNetwork = await this.detectNetwork();\n    if (network.chainId !== currentNetwork.chainId) {\n      // We are allowing network changes, things can get complex fast;\n      // make sure you know what you are doing if you use \"any\"\n      if (this.anyNetwork) {\n        this._network = currentNetwork;\n\n        // Reset all internal block number guards and caches\n        this._lastBlockNumber = -2;\n        this._fastBlockNumber = null;\n        this._fastBlockNumberPromise = null;\n        this._fastQueryDate = 0;\n        this._emitted.block = -2;\n        this._maxInternalBlockNumber = -1024;\n        this._internalBlockNumber = null;\n\n        // The \"network\" event MUST happen before this method resolves\n        // so any events have a chance to unregister, so we stall an\n        // additional event loop before returning from /this/ call\n        this.emit('network', currentNetwork, network);\n        await stall(0);\n\n        return this._network;\n      }\n\n      const error = logger.makeError(\n        'underlying network changed',\n        Logger.errors.NETWORK_ERROR,\n        {\n          event: 'changed',\n          network: network,\n          detectedNetwork: currentNetwork,\n        }\n      );\n\n      this.emit('error', error);\n      throw error;\n    }\n\n    return network;\n  }\n\n  get blockNumber(): number {\n    this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n\n    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;\n  }\n\n  get polling(): boolean {\n    return this._poller != null;\n  }\n\n  set polling(value: boolean) {\n    if (value && !this._poller) {\n      this._poller = setInterval(this.poll.bind(this), this.pollingInterval);\n\n      if (!this._bootstrapPoll) {\n        this._bootstrapPoll = setTimeout(() => {\n          this.poll();\n\n          // We block additional polls until the polling interval\n          // is done, to prevent overwhelming the poll function\n          this._bootstrapPoll = setTimeout(() => {\n            // If polling was disabled, something may require a poke\n            // since starting the bootstrap poll and it was disabled\n            if (!this._poller) {\n              this.poll();\n            }\n\n            // Clear out the bootstrap so we can do another\n            this._bootstrapPoll = null;\n          }, this.pollingInterval);\n        }, 0);\n      }\n    } else if (!value && this._poller) {\n      clearInterval(this._poller);\n      this._poller = null;\n    }\n  }\n\n  get pollingInterval(): number {\n    return this._pollingInterval;\n  }\n\n  set pollingInterval(value: number) {\n    if (\n      typeof value !== 'number' ||\n      value <= 0 ||\n      parseInt(String(value)) != value\n    ) {\n      throw new Error('invalid polling interval');\n    }\n\n    this._pollingInterval = value;\n\n    if (this._poller) {\n      clearInterval(this._poller);\n      this._poller = setInterval(() => {\n        this.poll();\n      }, this._pollingInterval);\n    }\n  }\n\n  _getFastBlockNumber(): Promise<number> {\n    const now = getTime();\n\n    // Stale block number, request a newer value\n    if (now - this._fastQueryDate > 2 * this._pollingInterval) {\n      this._fastQueryDate = now;\n      this._fastBlockNumberPromise = this.getBlockNumber().then(\n        (blockNumber) => {\n          if (\n            this._fastBlockNumber == null ||\n            blockNumber > this._fastBlockNumber\n          ) {\n            this._fastBlockNumber = blockNumber;\n          }\n          return this._fastBlockNumber;\n        }\n      );\n    }\n\n    return this._fastBlockNumberPromise;\n  }\n\n  _setFastBlockNumber(blockNumber: number): void {\n    // Older block, maybe a stale request\n    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n      return;\n    }\n\n    // Update the time we updated the blocknumber\n    this._fastQueryDate = getTime();\n\n    // Newer block number, use  it\n    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n      this._fastBlockNumber = blockNumber;\n      this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n    }\n  }\n\n  async waitForTransaction(\n    transactionHash: string,\n    confirmations?: number,\n    timeout?: number\n  ): Promise<TransactionInfoView> {\n    if (confirmations == null) {\n      confirmations = 1;\n    }\n\n    const transactionInfo = await this.getTransactionInfo(transactionHash);\n    // Receipt is already good\n    if (\n      (transactionInfo ? transactionInfo.confirmations : 0) >= confirmations\n    ) {\n      return Promise.resolve(transactionInfo);\n    }\n\n    // Poll until the receipt is good...\n    return new Promise((resolve, reject) => {\n      let timer: NodeJS.Timer = null;\n      let done = false;\n\n      const handler = (transactionInfo: TransactionInfoView) => {\n        if (transactionInfo.confirmations < confirmations) {\n          return;\n        }\n\n        if (timer) {\n          clearTimeout(timer);\n        }\n        if (done) {\n          return;\n        }\n        done = true;\n\n        this.removeListener(transactionHash, handler);\n        resolve(transactionInfo);\n      };\n      this.on(transactionHash, handler);\n\n      if (typeof timeout === 'number' && timeout > 0) {\n        timer = setTimeout(() => {\n          if (done) {\n            return;\n          }\n          timer = null;\n          done = true;\n\n          this.removeListener(transactionHash, handler);\n          reject(\n            logger.makeError('timeout exceeded', Logger.errors.TIMEOUT, {\n              timeout: timeout,\n            })\n          );\n        }, timeout);\n        if (timer.unref) {\n          timer.unref();\n        }\n      }\n    });\n  }\n\n  async getBlockNumber(): Promise<number> {\n    return this._getInternalBlockNumber(0);\n  }\n\n  async getGasPrice(): Promise<U64> {\n    await this.getNetwork();\n    const result = await this.perform(RPC_ACTION.getGasPrice, {});\n    return this.formatter.u64(result);\n  }\n\n  // async getBalance(\n  //   addressOrName: string | Promise<string>,\n  //   blockTag?: BlockTag | Promise<BlockTag>\n  // ): Promise<BigNumber> {\n  //   await this.getNetwork();\n  //   const params = await resolveProperties({\n  //     address: this._getAddress(addressOrName),\n  //     blockTag: this._getBlockTag(blockTag),\n  //   });\n  //   return BigNumber.from(await this.perform('getBalance', params));\n  // }\n\n  // async getTransactionCount(\n  //   addressOrName: string | Promise<string>,\n  //   blockTag?: BlockTag | Promise<BlockTag>\n  // ): Promise<number> {\n  //   await this.getNetwork();\n  //   const params = await resolveProperties({\n  //     address: this._getAddress(addressOrName),\n  //     blockTag: this._getBlockTag(blockTag),\n  //   });\n  //   return BigNumber.from(\n  //     await this.perform('getTransactionCount', params)\n  //   ).toNumber();\n  // }\n\n  // eslint-disable-next-line consistent-return\n  async getCode(\n    moduleId: ModuleId | Promise<ModuleId>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<string | undefined> {\n    await this.getNetwork();\n    const params = await resolveProperties({\n      moduleId: BaseProvider.getModuleId(await moduleId),\n      blockTag,\n    });\n    const code = await this.perform(RPC_ACTION.getCode, params);\n    if (code) {\n      return hexlify(code);\n    }\n  }\n\n  // get resource data.\n  // eslint-disable-next-line consistent-return\n  async getResource(\n    address: AccountAddress | Promise<AccountAddress>,\n    resource_struct_tag: string | Promise<string>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<MoveStruct | undefined> {\n    await this.getNetwork();\n    const params = await resolveProperties({\n      address,\n      structTag: resource_struct_tag,\n      blockTag,\n    });\n    const value = await this.perform(RPC_ACTION.getResource, params);\n    if (value) {\n      return this.formatter.moveStruct(value);\n    }\n  }\n\n  async getResources(\n    address: AccountAddress | Promise<AccountAddress>,\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<{ [k: string]: MoveStruct } | undefined> {\n    await this.getNetwork();\n    const params = await resolveProperties({\n      address,\n      blockTag,\n    });\n    const value = await this.perform(RPC_ACTION.getAccountState, params);\n    if (value) {\n      // @ts-ignore\n      return Object.entries(value.resources).reduce(\n        (o, [k, v]) => ({\n          ...o,\n          [k]: this.formatter.moveStruct(v as AnnotatedMoveStruct),\n        }),\n        {}\n      );\n    }\n  }\n\n  // This should be called by any subclass wrapping a TransactionResponse\n  protected _wrapTransaction(\n    tx: SignedUserTransactionView,\n    hash?: string\n  ): TransactionResponse {\n    if (hash != null && hexDataLength(hash) !== 32) {\n      throw new Error('invalid response - sendTransaction');\n    }\n\n    const result = <TransactionResponse>tx;\n\n    // Check the hash we expect is the same as the hash the server reported\n    if (hash != null && tx.transaction_hash !== hash) {\n      logger.throwError(\n        'Transaction hash mismatch from Provider.sendTransaction.',\n        Logger.errors.UNKNOWN_ERROR,\n        { expectedHash: tx.transaction_hash, returnedHash: hash }\n      );\n    }\n\n    // @TODO: (confirmations? number, timeout? number)\n    result.wait = async (confirmations?: number) => {\n      // We know this transaction *must* exist (whether it gets mined is\n      // another story), so setting an emitted value forces us to\n      // wait even if the node returns null for the receipt\n      if (confirmations !== 0) {\n        this._emitted[`t:${ tx.transaction_hash }`] = 'pending';\n      }\n\n      const receipt = await this.waitForTransaction(\n        tx.transaction_hash,\n        confirmations\n      );\n      if (receipt == null && confirmations === 0) {\n        return null;\n      }\n\n      // No longer pending, allow the polling loop to garbage collect this\n      this._emitted[`t:${ tx.transaction_hash }`] = receipt.block_number;\n\n      result.block_hash = receipt.block_hash;\n      result.block_number = receipt.block_number;\n      result.confirmations = confirmations;\n\n      if (receipt.status !== 'Executed') {\n        logger.throwError('transaction failed', Logger.errors.CALL_EXCEPTION, {\n          transactionHash: tx.transaction_hash,\n          transaction: tx,\n          receipt,\n        });\n      }\n      return receipt;\n    };\n\n    return result;\n  }\n\n  async sendTransaction(\n    signedTransaction: string | Promise<string>\n  ): Promise<TransactionResponse> {\n    await this.getNetwork();\n    const hexTx = await signedTransaction;\n    const tx = this.formatter.userTransactionData(hexTx);\n    try {\n      // FIXME: check rpc call\n      await this.perform(RPC_ACTION.sendTransaction, {\n        signedTransaction: hexTx,\n      });\n      return this._wrapTransaction(tx);\n    } catch (error) {\n      (<any>error).transaction = tx;\n      (<any>error).transactionHash = tx.transaction_hash;\n      throw error;\n    }\n  }\n\n  // async _getTransactionRequest(\n  //   transaction: Deferrable<TransactionRequest>\n  // ): Promise<Transaction> {\n  //   const values: any = await transaction;\n  //\n  //   const tx: any = {};\n  //\n  //   ['from', 'to'].forEach((key) => {\n  //     if (values[key] == null) {\n  //       return;\n  //     }\n  //     tx[key] = Promise.resolve(values[key]).then((v) =>\n  //       v ? this._getAddress(v) : null\n  //     );\n  //   });\n  //\n  //   ['gasLimit', 'gasPrice', 'value'].forEach((key) => {\n  //     if (values[key] == null) {\n  //       return;\n  //     }\n  //     tx[key] = Promise.resolve(values[key]).then((v) =>\n  //       v ? BigNumber.from(v) : null\n  //     );\n  //   });\n  //\n  //   ['data'].forEach((key) => {\n  //     if (values[key] == null) {\n  //       return;\n  //     }\n  //     tx[key] = Promise.resolve(values[key]).then((v) =>\n  //       v ? hexlify(v) : null\n  //     );\n  //   });\n  //\n  //   return this.formatter.transactionRequest(await resolveProperties(tx));\n  // }\n\n  private static getModuleId(moduleId: ModuleId): string {\n    if (typeof moduleId === 'string') {\n      return moduleId;\n    }\n\n    return `${ moduleId.address }::${ moduleId.name }`;\n  }\n\n  private async _getFilter(filter: Filter | Promise<Filter>): Promise<Filter> {\n    const result = await filter;\n\n    // const result: any = {};\n    //\n    // ['blockHash', 'topics'].forEach((key) => {\n    //   if ((<any>filter)[key] == null) {\n    //     return;\n    //   }\n    //   result[key] = (<any>filter)[key];\n    // });\n    //\n    // ['fromBlock', 'toBlock'].forEach((key) => {\n    //   if ((<any>filter)[key] == null) {\n    //     return;\n    //   }\n    //   result[key] = this._getBlockTag((<any>filter)[key]);\n    // });\n\n    return this.formatter.filter(await resolveProperties(result));\n  }\n\n  async call(\n    request: CallRequest | Promise<CallRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<Array<MoveValue>> {\n    await this.getNetwork();\n    const params = await resolveProperties({\n      request,\n    });\n    params.request.function_id = formatFunctionId(params.request.function_id);\n    // eslint-disable-next-line no-return-await\n    const rets = await this.perform(RPC_ACTION.call, params);\n    return rets.map((v) => this.formatter.moveValue(v));\n  }\n\n  async callV2(\n    request: CallRequest | Promise<CallRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    blockTag?: BlockTag | Promise<BlockTag>\n  ): Promise<Array<MoveValue>> {\n    await this.getNetwork();\n    const params = await resolveProperties({\n      request,\n    });\n    params.request.function_id = formatFunctionId(params.request.function_id);\n    // eslint-disable-next-line no-return-await\n    const rets = await this.perform(RPC_ACTION.callV2, params);\n    return rets.map((v) => v);\n  }\n\n  async dryRun(\n    transaction: Deferrable<TransactionRequest>\n  ): Promise<TransactionOutput> {\n    await this.getNetwork();\n    const params = await resolveProperties({\n      transaction,\n    });\n    const resp = await this.perform(RPC_ACTION.dryRun, params);\n    return this.formatter.transactionOutput(resp);\n  }\n\n  async dryRunRaw(\n    rawUserTransactionHex: string,\n    publicKeyHex: string\n  ): Promise<TransactionOutput> {\n    await this.getNetwork();\n    const params = { rawUserTransactionHex, publicKeyHex }\n    const resp = await this.perform(RPC_ACTION.dryRunRaw, params);\n    return this.formatter.transactionOutput(resp);\n  }\n\n  private async _getBlock(\n    blockHashOrBlockNumber: number | string | Promise<number | string>,\n    includeTransactions?: boolean\n  ): Promise<BlockView> {\n    await this.getNetwork();\n\n    blockHashOrBlockNumber = await blockHashOrBlockNumber;\n\n    // If blockTag is a number (not \"latest\", etc), this is the block number\n    let blockNumber = -128;\n\n    const params: { [key: string]: any } = {\n      includeTransactions: !!includeTransactions,\n    };\n\n    if (isHexString(blockHashOrBlockNumber, 32)) {\n      params.blockHash = blockHashOrBlockNumber;\n    } else {\n      try {\n        params.blockNumber = await this._getBlockTag(\n          blockHashOrBlockNumber as number\n        );\n        blockNumber = params.blockNumber;\n      } catch (error) {\n        logger.throwArgumentError(\n          'invalid block hash or block number',\n          'blockHashOrBlockNumber',\n          blockHashOrBlockNumber\n        );\n      }\n    }\n\n    return poll(\n      async () => {\n        const block = await this.perform(RPC_ACTION.getBlock, params);\n\n        // Block was not found\n        if (block == null) {\n          // For blockhashes, if we didn't say it existed, that blockhash may\n          // not exist. If we did see it though, perhaps from a log, we know\n          // it exists, and this node is just not caught up yet.\n          if (params.blockHash != null) {\n            if (this._emitted[`b:${ params.blockHash }`] == null) {\n              return null;\n            }\n          }\n\n          // For block number, if we are asking for a future block, we return null\n          if (params.blockNumber != null) {\n            if (blockNumber > this._emitted.block) {\n              return null;\n            }\n          }\n\n          // Retry on the next block\n          return undefined;\n        }\n\n        // Add transactions\n        if (includeTransactions) {\n          const blockNumber = await this._getInternalBlockNumber(\n            100 + 2 * this.pollingInterval\n          );\n\n          // Add the confirmations using the fast block number (pessimistic)\n          let confirmations = blockNumber - block.header.number + 1;\n          if (confirmations <= 0) {\n            confirmations = 1;\n          }\n          block.confirmations = confirmations;\n\n          return this.formatter.blockWithTransactions(block);\n        }\n\n        return this.formatter.blockWithTxnHashes(block);\n      },\n      { oncePoll: this }\n    );\n  }\n\n  // getBlock(\n  //   blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>\n  // ): Promise<BlockWithTxnHashes> {\n  //   return <Promise<BlockWithTxnHashes>>(\n  //     this._getBlock(blockHashOrBlockTag, true)\n  //   );\n  // }\n\n  getBlock(\n    blockTag: number | string | Promise<number | string>\n  ): Promise<BlockWithTransactions> {\n    return <Promise<BlockWithTransactions>>this._getBlock(blockTag, true);\n  }\n\n  async getTransaction(\n    transactionHash: string | Promise<string>\n  ): Promise<TransactionResponse> {\n    await this.getNetwork();\n    transactionHash = await transactionHash;\n\n    const params = {\n      transactionHash: this.formatter.hash(transactionHash, true),\n    };\n\n    return poll(\n      async () => {\n        const result = await this.perform(\n          RPC_ACTION.getTransactionByHash,\n          params\n        );\n\n        if (result == null) {\n          if (this._emitted[`t:${ transactionHash }`] == null) {\n            return null;\n          }\n          return undefined;\n        }\n\n        const tx = this.formatter.transactionResponse(result);\n\n        if (tx.block_number === undefined) {\n          tx.confirmations = 0;\n        } else if (tx.confirmations === undefined) {\n          const blockNumber = await this._getInternalBlockNumber(\n            100 + 2 * this.pollingInterval\n          );\n\n          // Add the confirmations using the fast block number (pessimistic)\n          let confirmations = blockNumber - tx.block_number + 1;\n          if (confirmations <= 0) {\n            confirmations = 1;\n          }\n          tx.confirmations = confirmations;\n        }\n\n        return this._wrapTransaction(tx);\n      },\n      { oncePoll: this }\n    );\n  }\n\n  async getTransactionInfo(\n    transactionHash: string | Promise<string>\n  ): Promise<TransactionInfoView> {\n    await this.getNetwork();\n\n    transactionHash = await transactionHash;\n\n    const params = {\n      transactionHash: this.formatter.hash(transactionHash, true),\n    };\n\n    return poll(\n      async () => {\n        const result = await this.perform(\n          RPC_ACTION.getTransactionInfo,\n          params\n        );\n\n        if (result === null) {\n          if (this._emitted[`t:${ transactionHash }`] === null) {\n            return null;\n          }\n          return undefined;\n        }\n\n        if (result.block_hash === null) {\n          return undefined;\n        }\n\n        const transactionInfo = this.formatter.transactionInfo(result);\n        if (transactionInfo.block_number === null) {\n          transactionInfo.confirmations = 0;\n        } else if (!transactionInfo.confirmations) {\n          const blockNumber = await this._getInternalBlockNumber(\n            100 + 2 * this.pollingInterval\n          );\n\n          // Add the confirmations using the fast block number (pessimistic)\n          let confirmations = blockNumber - transactionInfo.block_number + 1;\n          if (confirmations <= 0) {\n            confirmations = 1;\n          }\n\n          transactionInfo.confirmations = confirmations;\n        }\n        return transactionInfo;\n      },\n      { oncePoll: this }\n    );\n  }\n\n  async getEventsOfTransaction(\n    transactionHash: HashValue\n  ): Promise<TransactionEventView[]> {\n    await this.getNetwork();\n\n    transactionHash = await transactionHash;\n\n    const params = {\n      transactionHash: this.formatter.hash(transactionHash, true),\n    };\n    const logs: Array<TransactionEventView> = await this.perform(\n      RPC_ACTION.getEventsOfTransaction,\n      params\n    );\n    return Formatter.arrayOf(\n      this.formatter.transactionEvent.bind(this.formatter)\n    )(logs);\n  }\n\n  async getTransactionEvents(\n    filter: Filter | Promise<Filter>\n  ): Promise<Array<TransactionEventView>> {\n    await this.getNetwork();\n    const params = await resolveProperties({ filter });\n    const logs: Array<TransactionEventView> = await this.perform(\n      RPC_ACTION.getEvents,\n      params\n    );\n    return Formatter.arrayOf(\n      this.formatter.transactionEvent.bind(this.formatter)\n    )(logs);\n  }\n\n  async _getBlockTag(blockTag: number | Promise<number>): Promise<BlockNumber> {\n    blockTag = await blockTag;\n\n    if (blockTag < 0) {\n      if (blockTag % 1) {\n        logger.throwArgumentError('invalid BlockTag', 'blockTag', blockTag);\n      }\n\n      let blockNumber = await this._getInternalBlockNumber(\n        100 + 2 * this.pollingInterval\n      );\n      blockNumber += blockTag;\n      if (blockNumber < 0) {\n        blockNumber = 0;\n      }\n      return blockNumber;\n    } else {\n      return blockTag;\n    }\n  }\n\n  abstract perform(method: string, params: any): Promise<any>;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _startEvent(event: Event): void {\n    this.polling = this._events.filter((e) => e.pollable()).length > 0;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _stopEvent(event: Event): void {\n    this.polling = this._events.filter((e) => e.pollable()).length > 0;\n  }\n\n  _addEventListener(\n    eventName: EventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    const event = new Event(getEventTag(eventName), listener, once);\n    this._events.push(event);\n    this._startEvent(event);\n\n    return this;\n  }\n\n  on(eventName: EventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  once(eventName: EventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  emit(eventName: EventType, ...args: Array<any>): boolean {\n    let result = false;\n\n    const stopped: Array<Event> = [];\n\n    const eventTag = getEventTag(eventName);\n    this._events = this._events.filter((event) => {\n      if (event.tag !== eventTag) {\n        return true;\n      }\n\n      setTimeout(() => {\n        event.listener.apply(this, args);\n      }, 0);\n\n      result = true;\n\n      if (event.once) {\n        stopped.push(event);\n        return false;\n      }\n\n      return true;\n    });\n\n    stopped.forEach((event) => {\n      this._stopEvent(event);\n    });\n\n    return result;\n  }\n\n  listenerCount(eventName?: EventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getEventTag(eventName);\n    return this._events.filter((event) => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  listeners(eventName?: EventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map((event) => event.listener);\n    }\n\n    const eventTag = getEventTag(eventName);\n    return this._events\n      .filter((event) => event.tag === eventTag)\n      .map((event) => event.listener);\n  }\n\n  off(eventName: EventType, listener?: Listener): this {\n    if (listener === null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<Event> = [];\n\n    let found = false;\n\n    const eventTag = getEventTag(eventName);\n    this._events = this._events.filter((event) => {\n      if (event.tag !== eventTag || event.listener !== listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach((event) => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  removeAllListeners(eventName?: EventType): this {\n    let stopped: Array<Event> = [];\n    if (eventName === null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getEventTag(eventName);\n      this._events = this._events.filter((event) => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach((event) => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n}\n",
    "// eslint-disable-next-line max-classes-per-file\nimport { Bytes } from '@ethersproject/bytes';\nimport { deepCopy, Deferrable, defineReadOnly, resolveProperties, shallowCopy } from '@ethersproject/properties';\nimport { Logger } from '@ethersproject/logger';\nimport { Provider } from '../abstract-provider';\nimport { version } from '../version';\nimport { U128, U64, BlockTag, TransactionRequest, TransactionResponse } from '../types';\n\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys = new Set([\n  'sender',\n  'sender_public_key',\n  'sequence_number',\n  'script',\n  'modules',\n  'max_gas_amount',\n  'gas_unit_price',\n  'gas_token_code',\n  'chain_id'\n]);\n\n// FIXME: change the error data.\nconst forwardErrors = new Set([\n  Logger.errors.INSUFFICIENT_FUNDS,\n  Logger.errors.NONCE_EXPIRED,\n  Logger.errors.REPLACEMENT_UNDERPRICED\n]);\n\n\nexport abstract class Signer {\n  readonly provider?: Provider;\n\n  // Sub-classes MUST implement these\n\n  // Returns the address\n  abstract getAddress(): Promise<string>;\n\n  // Returns the signed prefixed-message. This MUST treat:\n  // - Bytes as a binary message\n  // - string as a UTF8-message\n  // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n  // abstract signMessage(message: Bytes | string): Promise<string>;\n  abstract signMessage(message: string): Promise<string>;\n\n  // Signs a transaction and returns the fully serialized, signed transaction.\n  // The EXACT transaction MUST be signed, and NO additional properties to be added.\n  // - This MAY throw if signing transactions is not supports, but if\n  //   it does, sentTransaction MUST be overridden.\n  abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n  // Returns a new instance of the Signer, connected to provider.\n  // This MAY throw if changing providers is not supported.\n  abstract connect(provider: Provider): Signer;\n\n  readonly _isSigner: boolean;\n\n\n  // Sub-classes MUST call super\n  constructor() {\n    logger.checkAbstract(new.target, Signer);\n    defineReadOnly(this, '_isSigner', true);\n  }\n\n\n  // Sub-classes MAY override these\n\n  async getBalance(token: string, blockTag?: BlockTag): Promise<U128> {\n    this.checkProvider('getBalance');\n    return this.provider.getBalance(this.getAddress(), token, blockTag);\n  }\n\n  // FIXME: check pending txn in txpool\n  async getSequenceNumber(blockTag?: BlockTag): Promise<U64> {\n    this.checkProvider('getSequenceNumber');\n    return this.provider.getSequenceNumber(this.getAddress(), blockTag);\n  }\n\n  // Populates \"from\" if unspecified, and estimates the gas for the transation\n  async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<U64> {\n    this.checkProvider('estimateGas');\n\n    const tx = await resolveProperties(this.checkTransaction(transaction));\n    const txnOutput = await this.provider.dryRun(tx);\n    if (typeof txnOutput.gas_used === 'number') {\n      return 3 * txnOutput.gas_used;\n    }\n    return 3n * txnOutput.gas_used.valueOf();\n  }\n\n  // calls with the transaction\n\n  // async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n  //   this.checkProvider('call');\n  //   const tx = await resolveProperties(this.checkTransaction(transaction));\n  //   return await this.provider.call(tx, blockTag);\n  // }\n\n  // Populates all fields in a transaction, signs it and sends it to the network\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n    this.checkProvider('sendTransaction');\n    return this.populateTransaction(transaction).then((tx) => {\n      return this.signTransaction(tx).then((signedTx) => {\n        return this.provider.sendTransaction(signedTx);\n      });\n    });\n  }\n\n  async getChainId(): Promise<number> {\n    this.checkProvider('getChainId');\n    const network = await this.provider.getNetwork();\n    return network.chainId;\n  }\n\n  async getGasPrice(): Promise<U64> {\n    this.checkProvider('getGasPrice');\n    return this.provider.getGasPrice();\n  }\n\n  // Checks a transaction does not contain invalid keys and if\n  // no \"from\" is provided, populates it.\n  // - does NOT require a provider\n  // - adds \"from\" is not present\n  // - returns a COPY (safe to mutate the result)\n  // By default called from: (overriding these prevents it)\n  //   - call\n  //   - estimateGas\n  //   - populateTransaction (and therefor sendTransaction)\n  checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key of Object.keys(transaction)) {\n      if (!allowedTransactionKeys.has(key)) {\n        logger.throwArgumentError(`invalid transaction key: ${key}`, 'transaction', transaction);\n      }\n    }\n\n    const tx = shallowCopy(transaction);\n\n    if (tx.sender === undefined) {\n      tx.sender = this.getAddress();\n    } else {\n      // Make sure any provided address matches this signer\n      tx.sender = Promise.all([\n        Promise.resolve(tx.sender),\n        this.getAddress()\n      ]).then((result) => {\n        if (result[0] !== result[1]) {\n          logger.throwArgumentError('from address mismatch', 'transaction', transaction);\n        }\n        return result[0];\n      });\n    }\n\n    return tx;\n  }\n\n  // Populates ALL keys for a transaction and checks that \"from\" matches\n  // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n  // By default called from: (overriding these prevents it)\n  //   - sendTransaction\n  async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n    const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction));\n    if (tx.gas_unit_price === undefined) {\n      tx.gas_unit_price = this.getGasPrice();\n    }\n    if (tx.sequence_number === undefined) {\n      tx.sequence_number = this.getSequenceNumber('pending');\n    }\n    if (tx.chain_id === undefined) {\n      tx.chain_id = this.getChainId();\n    } else {\n      tx.chain_id = Promise.all([\n        Promise.resolve(tx.chain_id),\n        this.getChainId()\n      ]).then((results) => {\n        if (results[1] !== 0 && results[0] !== results[1]) {\n          logger.throwArgumentError('chainId address mismatch', 'transaction', transaction);\n        }\n        return results[0];\n      });\n    }\n\n    if (tx.max_gas_amount === undefined) {\n      tx.max_gas_amount = this.estimateGas(tx).catch((error) => {\n        if (forwardErrors.has(error.code)) {\n          throw error;\n        }\n        console.log(`err: ${error}`);\n        return logger.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n          error,\n          tx\n        });\n      });\n    }\n\n    return resolveProperties(tx);\n  }\n\n\n  // Sub-classes SHOULD leave these alone\n\n  // eslint-disable-next-line no-underscore-dangle\n  checkProvider(operation?: string): void {\n    if (!this.provider) {\n      logger.throwError('missing provider', Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: (operation || '_checkProvider')\n      });\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  static isSigner(value: any): value is Signer {\n    // eslint-disable-next-line no-underscore-dangle\n    return !!(value && value._isSigner);\n  }\n}\n\nexport class VoidSigner extends Signer {\n  readonly address: string;\n\n  constructor(address: string, provider?: Provider) {\n    logger.checkNew(new.target, VoidSigner);\n    super();\n    defineReadOnly(this, 'address', address);\n    defineReadOnly(this, 'provider', provider);\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve(this.address);\n  }\n\n  // eslint-disable-next-line no-underscore-dangle,class-methods-use-this\n  private fail(message: string, operation: string): Promise<any> {\n    // eslint-disable-next-line promise/always-return\n    return Promise.resolve().then(() => {\n      logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  signMessage(message: string): Promise<string> {\n    return this.fail('VoidSigner cannot sign messages', 'signMessage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n    return this.fail('VoidSigner cannot sign transactions', 'signTransaction');\n  }\n\n  connect(provider: Provider): VoidSigner {\n    return new VoidSigner(this.address, provider);\n  }\n}\n\n",
    "// eslint-disable-next-line max-classes-per-file\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { Logger } from '@ethersproject/logger';\nimport {\n  deepCopy,\n  Deferrable,\n  defineReadOnly,\n  getStatic,\n  resolveProperties,\n  shallowCopy,\n} from '@ethersproject/properties';\nimport { ConnectionInfo, fetchJson } from '@ethersproject/web';\nimport { Bytes, isBytes, hexlify, hexValue } from '@ethersproject/bytes';\nimport { getNetwork, Network, Networkish } from '../networks';\nimport { version } from '../version';\nimport { BaseProvider, CONSTANTS, Event, RPC_ACTION } from './base-provider';\n// eslint-disable-next-line import/order\nimport { ChainId, TransactionRequest } from '../types';\nimport { Signer } from '../abstract-signer';\nimport { Provider } from '../abstract-provider';\nimport { checkProperties } from '../utils/properties';\n\nconst logger = new Logger(version);\n\nconst errorGas = new Set(['call', 'estimateGas']);\n\n// FIXME: recheck the error.\nfunction checkError(method: string, error: any, params: any): never {\n  let { message } = error;\n  if (\n    error.code === Logger.errors.SERVER_ERROR &&\n    error.error &&\n    typeof error.error.message === 'string'\n  ) {\n    message = error.error.message;\n  } else if (typeof error.body === 'string') {\n    message = error.body;\n  } else if (typeof error.responseText === 'string') {\n    message = error.responseText;\n  }\n  message = (message || '').toLowerCase();\n\n  const transaction = params.transaction || params.signedTransaction;\n\n  // \"insufficient funds for gas * price + value + cost(data)\"\n  if (message.match(/insufficient funds/)) {\n    logger.throwError(\n      'insufficient funds for intrinsic transaction cost',\n      Logger.errors.INSUFFICIENT_FUNDS,\n      {\n        error,\n        method,\n        transaction,\n      }\n    );\n  }\n\n  // \"nonce too low\"\n  if (message.match(/nonce too low/)) {\n    logger.throwError(\n      'nonce has already been used',\n      Logger.errors.NONCE_EXPIRED,\n      {\n        error,\n        method,\n        transaction,\n      }\n    );\n  }\n\n  // \"replacement transaction underpriced\"\n  if (message.match(/replacement transaction underpriced/)) {\n    logger.throwError(\n      'replacement fee too low',\n      Logger.errors.REPLACEMENT_UNDERPRICED,\n      {\n        error,\n        method,\n        transaction,\n      }\n    );\n  }\n\n  if (\n    errorGas.has(method) &&\n    message.match(\n      /gas required exceeds allowance|always failing transaction|execution reverted/\n    )\n  ) {\n    logger.throwError(\n      'cannot estimate gas; transaction may fail or may require manual gas limit',\n      Logger.errors.UNPREDICTABLE_GAS_LIMIT,\n      {\n        error,\n        method,\n        transaction,\n      }\n    );\n  }\n\n  throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, timeout);\n  });\n}\n\nfunction getResult(payload: {\n  error?: { code?: number; data?: any; message?: string };\n  result?: any;\n}): any {\n  if (payload.error) {\n    // @TODO: not any\n    const error: any = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer {\n  // eslint-disable-next-line no-use-before-define\n  readonly provider: JsonRpcProvider;\n  _index?: number;\n  _address?: string;\n\n  // eslint-disable-next-line no-use-before-define\n  constructor(\n    constructorGuard: any,\n    provider: JsonRpcProvider,\n    addressOrIndex?: string | number\n  ) {\n    logger.checkNew(new.target, JsonRpcSigner);\n\n    super();\n\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\n        'do not call the JsonRpcSigner constructor directly; use provider.getSigner'\n      );\n    }\n\n    defineReadOnly(this, 'provider', provider);\n\n    // eslint-disable-next-line no-param-reassign\n    if (addressOrIndex === undefined) {\n      addressOrIndex = 0;\n    }\n\n    if (typeof addressOrIndex === 'string') {\n      defineReadOnly(\n        this,\n        '_address',\n        this.provider.formatter.address(addressOrIndex)\n      );\n    } else if (typeof addressOrIndex === 'number') {\n      defineReadOnly(this, '_index', addressOrIndex);\n    } else {\n      logger.throwArgumentError(\n        'invalid address or index',\n        'addressOrIndex',\n        addressOrIndex\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars,class-methods-use-this\n  connect(provider: Provider): JsonRpcSigner {\n    return logger.throwError(\n      'cannot alter JSON-RPC Signer connection',\n      Logger.errors.UNSUPPORTED_OPERATION,\n      {\n        operation: 'connect',\n      }\n    );\n  }\n\n  // connectUnchecked(): JsonRpcSigner {\n  //   return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n  // }\n\n  async getAddress(): Promise<string> {\n    // eslint-disable-next-line no-underscore-dangle\n    if (this._address) {\n      // eslint-disable-next-line no-underscore-dangle\n      return Promise.resolve(this._address);\n    }\n\n    return this.provider.send(\"stc_accounts\", []).then((accounts) => {\n      if (accounts.length <= this._index) {\n        logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"getAddress\"\n        });\n      }\n      return this.provider.formatter.address(accounts[this._index])\n    });\n  }\n\n  sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n    logger.debug('sendUncheckedTransaction', transaction);\n    transaction = shallowCopy(transaction);\n\n    const fromAddress = this.getAddress().then((address) => {\n      if (address) { address = address.toLowerCase(); }\n      return address;\n    });\n    logger.debug(fromAddress)\n    // Since contract.dry_run_raw need publicKey, so we can not do it here.\n    // we can only do estimateGas in the StarMask -> MetaMaskController -> newUnapprovedTransaction\n\n    // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n    // wishes to use this, it is easy to specify explicitly, otherwise\n    // we look it up for them.\n    // if (transaction.gasLimit == null) {\n    //   const estimate = shallowCopy(transaction);\n    //   estimate.from = fromAddress;\n    //   transaction.gasLimit = this.provider.estimateGas(estimate);\n    // }\n\n    return resolveProperties({\n      tx: resolveProperties(transaction),\n      sender: fromAddress\n    }).then(({ tx, sender }) => {\n      if (tx.from != null) {\n        if (tx.from.toLowerCase() !== sender) {\n          logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n        }\n      } else {\n        tx.from = sender;\n      }\n\n      const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true, expiredSecs: true, addGasBufferMultiplier: true });\n      if (tx.addGasBufferMultiplier && typeof tx.addGasBufferMultiplier === 'number') {\n        hexTx.addGasBufferMultiplier = tx.addGasBufferMultiplier.toString();\n      }\n      logger.debug(hexTx);\n      return this.provider.send(\"stc_sendTransaction\", [hexTx]).then((hash) => {\n        return hash;\n      }, (error) => {\n        if (error.responseText) {\n          // See: JsonRpcProvider.sendTransaction (@TODO: Expose a ._throwError??)\n          if (error.responseText.indexOf(\"insufficient funds\") >= 0) {\n            logger.throwError(\"insufficient funds\", Logger.errors.INSUFFICIENT_FUNDS, {\n              transaction: tx\n            });\n          }\n          if (error.responseText.indexOf(\"nonce too low\") >= 0) {\n            logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n              transaction: tx\n            });\n          }\n          if (error.responseText.indexOf(\"replacement transaction underpriced\") >= 0) {\n            logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n              transaction: tx\n            });\n          }\n        }\n        throw error;\n      });\n    });\n  }\n\n  async signTransaction(\n    transaction: Deferrable<TransactionRequest>\n  ): Promise<string> {\n    // eslint-disable-next-line no-param-reassign\n    const request = await resolveProperties(transaction);\n    const sender = await this.getAddress();\n    if (request.sender !== undefined) {\n      if (request.sender !== sender) {\n        logger.throwArgumentError(\n          'from address mismatch',\n          'transaction',\n          transaction\n        );\n      }\n    } else {\n      request.sender = sender;\n    }\n\n    return this.provider.send('account.sign_txn_request', [request]).then(\n      (hexTxnData) => {\n        return hexTxnData;\n      },\n      (error) => {\n        return checkError('signTransaction', error, request);\n      }\n    );\n  }\n\n  // eslint-disable-next-line class-methods-use-this,@typescript-eslint/no-unused-vars\n  async signMessage(message: Bytes | string): Promise<string> {\n    // return logger.throwError('signing message is unsupported', Logger.errors.UNSUPPORTED_OPERATION, {\n    //  operation: 'signMessage'\n    // });\n    const { provider } = this;\n    const address = await this.getAddress();\n    let u8a;\n    if (typeof message === 'string') {\n      u8a = new Uint8Array(Buffer.from(message));\n    } else if (isBytes(message)) {\n      u8a = message;\n    } else {\n      return logger.throwError(\n        'type of message input is unsupported',\n        Logger.errors.UNSUPPORTED_OPERATION,\n        {\n          operation: 'signMessage',\n        }\n      );\n    }\n    const msgArray = Array.from(u8a);\n    const messageArg = { message: msgArray };\n    return provider.send('account.sign', [address.toLowerCase(), messageArg]);\n    /*\n    return this.provider.send('account.sign', [request]).then((hexSignedMessageData) => {\n        return hexSignedMessageData;\n      },\n      (error) => {\n        return checkError('signMessage', error, request);\n      });\n    */\n    // const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n    // const address = await this.getAddress();\n    //\n    // // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    // return this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n  }\n\n  async unlock(password: string): Promise<void> {\n    const { provider } = this;\n\n    const address = await this.getAddress();\n\n    return provider.send('account.unlock', [\n      address.toLowerCase(),\n      password,\n      undefined,\n    ]);\n  }\n}\n\n// class UncheckedJsonRpcSigner extends JsonRpcSigner {\n//   sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n//     return this.sendUncheckedTransaction(transaction).then((hash) => {\n//       return <TransactionResponse>{\n//         hash: hash,\n//         nonce: null,\n//         gasLimit: null,\n//         gasPrice: null,\n//         data: null,\n//         value: null,\n//         chainId: null,\n//         confirmations: 0,\n//         from: null,\n//         wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n//       };\n//     });\n//   }\n// }\n\nconst allowedTransactionKeys: { [key: string]: boolean } = {\n  chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n}\nexport class JsonRpcProvider extends BaseProvider {\n  readonly connection: ConnectionInfo;\n\n  _pendingFilter: Promise<number>;\n  _nextId: number;\n\n  constructor(url?: ConnectionInfo | string, network?: Networkish) {\n    logger.checkNew(new.target, JsonRpcProvider);\n\n    let networkOrReady: Networkish | Promise<Network> = network;\n\n    // The network is unknown, query the JSON-RPC for it\n    if (networkOrReady == null) {\n      networkOrReady = new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.detectNetwork().then(\n            (network) => {\n              resolve(network);\n            },\n            (error) => {\n              reject(error);\n            }\n          );\n        }, 0);\n      });\n    }\n\n    super(networkOrReady);\n\n    // Default URL\n    if (!url) {\n      url = getStatic<() => string>(this.constructor, 'defaultUrl')();\n    }\n\n    if (typeof url === 'string') {\n      defineReadOnly(\n        this,\n        'connection',\n        Object.freeze({\n          url: url,\n        })\n      );\n    } else {\n      defineReadOnly(this, 'connection', Object.freeze(shallowCopy(url)));\n    }\n\n    this._nextId = 42;\n  }\n\n  static defaultUrl(): string {\n    return 'http://localhost:9850';\n  }\n\n  async detectNetwork(): Promise<Network> {\n    await timer(0);\n\n    let chainId = null;\n    try {\n      const resp = (await this.send('chain.id', [])) as ChainId;\n      chainId = resp.id;\n    } catch (error) {\n      try {\n        const chainInfo = await this.perform(RPC_ACTION.getChainInfo, null);\n        chainId = chainInfo.chain_id;\n        // eslint-disable-next-line no-empty\n      } catch (error) { }\n    }\n\n    if (chainId != null) {\n      try {\n        return getNetwork(BigNumber.from(chainId).toNumber());\n      } catch (error) {\n        return logger.throwError(\n          'could not detect network',\n          Logger.errors.NETWORK_ERROR,\n          {\n            chainId: chainId,\n            event: 'invalidNetwork',\n            serverError: error,\n          }\n        );\n      }\n    }\n\n    return logger.throwError(\n      'could not detect network',\n      Logger.errors.NETWORK_ERROR,\n      {\n        event: 'noNetwork',\n      }\n    );\n  }\n\n  getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n  }\n\n  // getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n  //   return this.getSigner(addressOrIndex).connectUnchecked();\n  // }\n\n  async getNowSeconds(): Promise<number> {\n    const nodeInfo = await this.perform(RPC_ACTION.getNodeInfo, null);\n    return nodeInfo.now_seconds;\n  }\n\n  send(method: string, params: Array<any>): Promise<any> {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0',\n    };\n\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this,\n    });\n\n    return fetchJson(this.connection, JSON.stringify(request), getResult).then(\n      (result) => {\n        this.emit('debug', {\n          action: 'response',\n          request,\n          response: result,\n          provider: this,\n        });\n\n        return result;\n      },\n      (error) => {\n        this.emit('debug', {\n          action: 'response',\n          error,\n          request,\n          provider: this,\n        });\n\n        throw error;\n      }\n    );\n  }\n\n  // eslint-disable-next-line consistent-return\n  prepareRequest(method: string, params: any): [string, Array<any>] {\n    switch (method) {\n      case RPC_ACTION.getChainInfo:\n        return ['chain.info', []];\n      case RPC_ACTION.getNodeInfo:\n        return ['node.info', []];\n      case RPC_ACTION.getGasPrice:\n        return ['txpool.gas_price', []];\n      case RPC_ACTION.dryRun:\n        return ['contract.dry_run', [params.transaction]];\n      case RPC_ACTION.dryRunRaw:\n        return ['contract.dry_run_raw', [params.rawUserTransactionHex, params.publicKeyHex]];\n      // case 'getBalance':\n      //   return [\n      //     'eth_getBalance',\n      //     [getLowerCase(params.address), params.blockTag],\n      //   ];\n      // case 'getTransactionCount':\n      //   return [\n      //     'eth_getTransactionCount',\n      //     [getLowerCase(params.address), params.blockTag],\n      //   ];\n\n      // case 'getCode':\n      //   return ['eth_getCode', [getLowerCase(params.address), params.blockTag]];\n      //\n      // case 'getStorageAt':\n      //   return [\n      //     'eth_getStorageAt',\n      //     [getLowerCase(params.address), params.position, params.blockTag],\n      //   ];\n      case RPC_ACTION.sendTransaction:\n        return ['txpool.submit_hex_transaction', [params.signedTransaction]];\n      case RPC_ACTION.getBlock:\n        if (params.blockNumber !== undefined) {\n          return ['chain.get_block_by_number', [params.blockNumber]];\n        }\n        if (params.blockHash !== undefined) {\n          return ['chain.get_block_by_hash', [params.blockHash]];\n        }\n        break;\n      case RPC_ACTION.getTransactionByHash:\n        return ['chain.get_transaction', [params.transactionHash]];\n\n      case RPC_ACTION.getTransactionInfo:\n        return ['chain.get_transaction_info', [params.transactionHash]];\n      case RPC_ACTION.getEventsOfTransaction:\n        return ['chain.get_events_by_txn_hash', [params.transactionHash]];\n      case RPC_ACTION.getCode:\n        return ['contract.get_code', [params.moduleId]];\n      case RPC_ACTION.getResource:\n        return ['contract.get_resource', [params.address, params.structTag]];\n      case RPC_ACTION.getAccountState:\n        return ['state.get_account_state_set', [params.address]];\n      case RPC_ACTION.call:\n        return ['contract.call', [params.request]];\n      case RPC_ACTION.callV2:\n        return ['contract.call_v2', [params.request]];\n\n      // case 'estimateGas': {\n      //   const hexlifyTransaction = getStatic<\n      //     (\n      //       t: TransactionRequest,\n      //       a?: { [key: string]: boolean }\n      //     ) => { [key: string]: string }\n      //   >(this.constructor, 'hexlifyTransaction');\n      //   return [\n      //     'eth_estimateGas',\n      //     [hexlifyTransaction(params.transaction, { from: true })],\n      //   ];\n      // }\n      case RPC_ACTION.getEvents:\n        return ['chain.get_events', [params.filter]];\n      default:\n        break;\n      // if (params instanceof Array) {\n      //   return [method, params];\n      // } else {\n      //   return [method, [params]];\n      // }\n    }\n  }\n\n  async perform(method: string, params: any): Promise<any> {\n    const args = this.prepareRequest(method, params);\n\n    if (args === undefined) {\n      logger.throwError(\n        `${ method } not implemented`,\n        Logger.errors.NOT_IMPLEMENTED,\n        { operation: method }\n      );\n    }\n\n    try {\n      return await this.send(args[0], args[1]);\n    } catch (error) {\n      return checkError(method, error, params);\n    }\n  }\n\n  _startEvent(event: Event): void {\n    if (event.tag === 'pending') {\n      // this._startPending();\n      logger.throwError(\n        'pending event not implemented',\n        Logger.errors.NOT_IMPLEMENTED,\n        { operation: 'pending event' }\n      );\n    }\n    super._startEvent(event);\n  }\n\n  // _startPending(): void {\n  //   if (this._pendingFilter != null) {\n  //     return;\n  //   }\n  //   // eslint-disable-next-line @typescript-eslint/no-this-alias\n  //   const self = this;\n  //\n  //   const pendingFilter: Promise<number> = this.send(\n  //     'eth_newPendingTransactionFilter',\n  //     []\n  //   );\n  //   this._pendingFilter = pendingFilter;\n  //\n  //   pendingFilter\n  //     .then(function (filterId) {\n  //       function poll() {\n  //         self\n  //           .send('eth_getFilterChanges', [filterId])\n  //           .then(function (hashes: Array<string>) {\n  //             if (self._pendingFilter != pendingFilter) {\n  //               return null;\n  //             }\n  //\n  //             let seq = Promise.resolve();\n  //             hashes.forEach(function (hash) {\n  //               // @TODO: This should be garbage collected at some point... How? When?\n  //               // @ts-ignore\n  //               self._emitted['t:' + hash.toLowerCase()] = CONSTANTS.pending;\n  //               seq = seq.then(function () {\n  //                 return self.getTransaction(hash).then(function (tx) {\n  //                   self.emit(CONSTANTS.pending, tx);\n  //                   return null;\n  //                 });\n  //               });\n  //             });\n  //\n  //             return seq.then(function () {\n  //               return timer(1000);\n  //             });\n  //           })\n  //           .then(function () {\n  //             if (self._pendingFilter != pendingFilter) {\n  //               self.send('eth_uninstallFilter', [filterId]);\n  //               return;\n  //             }\n  //             setTimeout(function () {\n  //               poll();\n  //             }, 0);\n  //\n  //             return null;\n  //           })\n  //           // eslint-disable-next-line @typescript-eslint/no-empty-function\n  //           .catch((error: Error) => {});\n  //       }\n  //       poll();\n  //\n  //       return filterId;\n  //     })\n  //     // eslint-disable-next-line @typescript-eslint/no-empty-function\n  //     .catch((error: Error) => {});\n  // }\n\n  _stopEvent(event: Event): void {\n    if (\n      event.tag === CONSTANTS.pending &&\n      this.listenerCount(CONSTANTS.pending) === 0\n    ) {\n      this._pendingFilter = null;\n    }\n    super._stopEvent(event);\n  }\n\n  // Convert an ethers.js transaction into a JSON-RPC transaction\n  //  - gasLimit => gas\n  //  - All values hexlified\n  //  - All numeric values zero-striped\n  //  - All addresses are lowercased\n  // NOTE: This allows a TransactionRequest, but all values should be resolved\n  //       before this is called\n  // @TODO: This will likely be removed in future versions and prepareRequest\n  //        will be the preferred method for this.\n  static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string } {\n    // Check only allowed properties are given\n    const allowed = shallowCopy(allowedTransactionKeys);\n    if (allowExtra) {\n      for (const key in allowExtra) {\n        if (allowExtra[key]) { allowed[key] = true; }\n      }\n    }\n    checkProperties(transaction, allowed);\n\n    const result: { [key: string]: string } = {};\n\n    // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n    [\"gasLimit\", \"gasPrice\", \"nonce\", \"value\", \"expiredSecs\"].forEach(function (key) {\n      if ((<any>transaction)[key] == null) { return; }\n      const value = hexValue((<any>transaction)[key]);\n      if (key === \"gasLimit\") { key = \"gas\"; }\n      result[key] = value;\n    });\n\n    [\"from\", \"to\", \"data\"].forEach(function (key) {\n      if ((<any>transaction)[key] == null) { return; }\n      result[key] = hexlify((<any>transaction)[key]);\n    });\n\n    return result;\n  }\n}\n",
    "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as ed from '@starcoin/stc-ed25519';\nimport { stripHexPrefix, addHexPrefix } from 'ethereumjs-util';\nimport { arrayify, hexlify, isHexString } from '@ethersproject/bytes';\nimport { bytes, Seq, uint8 } from '../lib/runtime/serde';\nimport * as starcoin_types from '../lib/runtime/starcoin_types';\nimport { BcsSerializer } from '../lib/runtime/bcs';\nimport { FunctionId, HexString, parseFunctionId, TypeTag, U128, U64, U8 } from '../types';\nimport { addressToSCS, addressFromSCS, typeTagToSCS, bcsEncode } from '../encoding';\nimport { createRawUserTransactionHasher } from \"../crypto_hash\";\n// import { MultiEd25519KeyShard } from \"../crypto\";\nimport { JsonRpcProvider } from '../providers/jsonrpc-provider';\nimport { fromHexString } from './hex';\n\nexport function encodeTransactionScript(\n  code: bytes,\n  ty_args: TypeTag[],\n  args: HexString[]\n): starcoin_types.TransactionPayloadVariantScript {\n  const script = new starcoin_types.Script(\n    code,\n    ty_args.map((t) => typeTagToSCS(t)),\n    args.map((t) => arrayify(t))\n  );\n  return new starcoin_types.TransactionPayloadVariantScript(script);\n}\n\nexport function encodeScriptFunction(functionId: FunctionId,\n  tyArgs: TypeTag[],\n  args: bytes[]): starcoin_types.TransactionPayloadVariantScriptFunction {\n  const funcId = parseFunctionId(functionId);\n  const scriptFunction = new starcoin_types.ScriptFunction(\n    new starcoin_types.ModuleId(addressToSCS(funcId.address), new starcoin_types.Identifier(funcId.module)),\n    new starcoin_types.Identifier(funcId.functionName),\n    tyArgs.map((t) => typeTagToSCS(t)),\n    args\n  );\n  return new starcoin_types.TransactionPayloadVariantScriptFunction(scriptFunction);\n}\n\nexport function encodePackage(\n  moduleAddress: string,\n  moduleCodes: HexString[],\n  initScriptFunction?: { functionId: FunctionId; tyArgs: TypeTag[]; args: bytes[] }\n): starcoin_types.TransactionPayloadVariantPackage {\n  const modules = moduleCodes.map((m) => new starcoin_types.Module(arrayify(m)));\n  let scriptFunction = null;\n  if (!!initScriptFunction) {\n    scriptFunction = encodeScriptFunction(initScriptFunction.functionId, initScriptFunction.tyArgs, initScriptFunction.args);\n  }\n  const packageData = new starcoin_types.Package(\n    addressToSCS(moduleAddress),\n    modules,\n    scriptFunction\n  );\n  return new starcoin_types.TransactionPayloadVariantPackage(\n    packageData\n  );\n}\n\n// Step 1: generate RawUserTransaction\nexport function generateRawUserTransaction(\n  senderAddress: HexString,\n  payload: starcoin_types.TransactionPayload,\n  maxGasAmount: U64,\n  gasUnitPrice: U64,\n  senderSequenceNumber: U64,\n  expirationTimestampSecs: U64,\n  chainId: U8\n): starcoin_types.RawUserTransaction {\n\n  // Step 1-2: generate RawUserTransaction\n  const sender = addressToSCS(senderAddress)\n  const sequence_number = BigInt(senderSequenceNumber)\n\n  const max_gas_amount = BigInt(maxGasAmount)\n  const gas_unit_price = BigInt(gasUnitPrice)\n  const gas_token_code = '0x1::STC::STC'\n  const expiration_timestamp_secs = BigInt(expirationTimestampSecs)\n  const chain_id = new starcoin_types.ChainId(chainId)\n\n  const rawUserTransaction = new starcoin_types.RawUserTransaction(sender, sequence_number, payload, max_gas_amount, gas_unit_price, gas_token_code, expiration_timestamp_secs, chain_id)\n\n  return rawUserTransaction\n}\n\nexport async function getSignatureHex(\n  rawUserTransaction: starcoin_types.RawUserTransaction,\n  senderPrivateKey: HexString,\n): Promise<string> {\n\n  const hasher = createRawUserTransactionHasher();\n  const hashSeedBytes = hasher.get_salt();\n\n  const rawUserTransactionBytes = (function () {\n    const se = new BcsSerializer();\n    rawUserTransaction.serialize(se);\n    return se.getBytes();\n  })();\n\n  const msgBytes = ((a, b) => {\n    const tmp = new Uint8Array(a.length + b.length);\n    tmp.set(a, 0);\n    tmp.set(b, a.length);\n    return tmp;\n  })(hashSeedBytes, rawUserTransactionBytes);\n\n  const signatureBytes = await ed.sign(msgBytes, stripHexPrefix(senderPrivateKey))\n  const signatureHex = hexlify(signatureBytes)\n\n  return signatureHex\n}\n\nasync function generateSignedUserTransaction(\n  senderPrivateKey: string,\n  signatureHex: string,\n  rawUserTransaction: starcoin_types.RawUserTransaction\n): Promise<starcoin_types.SignedUserTransaction> {\n  const senderPublicKeyMissingPrefix = <string><unknown>await ed.getPublicKey(stripHexPrefix(senderPrivateKey))\n  const signedUserTransaction = signTxn(senderPublicKeyMissingPrefix, signatureHex, rawUserTransaction)\n  return Promise.resolve(signedUserTransaction)\n}\n\nexport function signTxn(\n  senderPublicKey: string,\n  signatureHex: string,\n  rawUserTransaction: starcoin_types.RawUserTransaction\n): starcoin_types.SignedUserTransaction {\n  // Step 3-1: generate authenticator\n  const public_key = new starcoin_types.Ed25519PublicKey(arrayify(addHexPrefix(senderPublicKey)))\n  const signature = new starcoin_types.Ed25519Signature(arrayify(addHexPrefix(signatureHex)))\n  const transactionAuthenticatorVariantEd25519 = new starcoin_types.TransactionAuthenticatorVariantEd25519(public_key, signature)\n\n  // Step 3-2: generate SignedUserTransaction\n  const signedUserTransaction = new starcoin_types.SignedUserTransaction(rawUserTransaction, transactionAuthenticatorVariantEd25519)\n\n  return signedUserTransaction\n}\n\n// export function signTransaction(\n//   authenticator: starcoin_types.TransactionAuthenticator,\n//   rawUserTransaction: starcoin_types.RawUserTransaction\n// ): starcoin_types.SignedUserTransaction {\n//   // Step 3-1: generate authenticator\n//   const transactionAuthenticatorVariantEd25519 = new starcoin_types.TransactionAuthenticatorVariantEd25519(public_key, signature)\n\n//   // Step 3-2: generate SignedUserTransaction\n//   const signedUserTransaction = new starcoin_types.SignedUserTransaction(rawUserTransaction, authenticator)\n\n//   return signedUserTransaction\n// }\n\nfunction getSignedUserTransactionHex(\n  signedUserTransaction: starcoin_types.SignedUserTransaction\n): string {\n  const se = new BcsSerializer();\n  signedUserTransaction.serialize(se);\n  return hexlify(se.getBytes());\n}\n\nexport async function getSignedUserTransaction(\n  senderPrivateKey: HexString,\n  rawUserTransaction: starcoin_types.RawUserTransaction\n): Promise<starcoin_types.SignedUserTransaction> {\n\n  // Step 2: generate signature of RawUserTransaction\n  const signatureHex = await getSignatureHex(rawUserTransaction, senderPrivateKey)\n\n  // Step 3: generate SignedUserTransaction\n  const signedUserTransaction = await generateSignedUserTransaction(senderPrivateKey, signatureHex, rawUserTransaction)\n\n  return signedUserTransaction\n}\n\nexport async function signRawUserTransaction(\n  senderPrivateKey: HexString,\n  rawUserTransaction: starcoin_types.RawUserTransaction\n): Promise<string> {\n\n  const signedUserTransaction = await getSignedUserTransaction(senderPrivateKey, rawUserTransaction)\n\n  // Step 4: get SignedUserTransaction Hex\n  const hex = getSignedUserTransactionHex(signedUserTransaction)\n\n  return hex\n}\n\nfunction encodeStructTypeTag(\n  str: string\n): TypeTag {\n  const arr = str.split('<');\n  const arr1 = arr[0].split('::');\n  const address = arr1[0];\n  const module = arr1[1];\n  const name = arr1[2];\n\n  const params = arr[1] ? arr[1].replace('>', '').split(',') : [];\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const type_params: TypeTag[] = [];\n  if (params.length > 0) {\n    params.forEach((param: string) => {\n      type_params.push(encodeStructTypeTag(param.trim()));\n    });\n  }\n\n  const result: TypeTag = {\n    Struct: {\n      address,\n      module,\n      name,\n      type_params,\n    },\n  }\n  return result\n}\n\n/**\n * while generate ScriptFunction, we need to encode a string array:\n[\n  'address1::module1::name1<address2::module2::name2>'\n]\n\ninto a TypeTag array:\n\n[\n  {\n    \"Struct\": {\n      \"address\": \"address1\",\n      \"module\": \"module1\",\n      \"name\": \"name1\",\n      \"type_params\": [\n        {\n          \"Struct\": {\n            \"address\": \"address2\",\n            \"module\": \"module2\",\n            \"name\": \"name2\",\n            \"type_params\": []\n          }\n        }\n      ]\n    }\n  }\n]\n */\nexport function encodeStructTypeTags(\n  typeArgsString: string[]\n): TypeTag[] {\n  return typeArgsString.map((str) => encodeStructTypeTag(str))\n}\n\nfunction serializeWithType(\n  value: any,\n  type: any\n): bytes {\n  if (type === 'Address') return arrayify(value);\n\n  const se = new BcsSerializer();\n\n  if (type && type.Vector === 'U8') {\n    if (!value) {\n      return Buffer.from('')\n    }\n    const valueBytes = isHexString(addHexPrefix(value)) ? fromHexString(value) : new Uint8Array(Buffer.from(value))\n    const { length } = valueBytes;\n    const list: Seq<uint8> = [];\n    for (let i = 0; i < length; i++) {\n      list.push(valueBytes[i]);\n    }\n    starcoin_types.Helpers.serializeVectorU8(list, se);\n    const hex = hexlify(se.getBytes());\n    return arrayify(hex);\n  }\n\n  if (type && type.Vector && Array.isArray(value)) {\n    se.serializeLen(value.length);\n    value.forEach((sub) => {\n      // array of string: vector<vector<u8>>\n      if (type.Vector.Vector === 'U8') {\n        se.serializeBytes(fromHexString(sub))\n      } else if (type.Vector) {\n        // array of other types: vector<u8>\n        se[`serialize${ type.Vector }`](sub);\n      }\n    });\n    const hex = hexlify(se.getBytes());\n    return arrayify(hex);\n  }\n\n  // For normal data type\n  if (type) {\n    se[`serialize${ type }`](value);\n    const hex = hexlify(se.getBytes());\n    return arrayify(hex);\n  }\n\n  return value;\n}\n\nexport function encodeScriptFunctionArgs(\n  argsType: any[],\n  args: any[]\n): bytes[] {\n  return args.map((value, index) => serializeWithType(value, argsType[index].type_tag))\n}\n\nexport async function encodeScriptFunctionByResolve(\n  functionId: FunctionId,\n  typeArgs: string[],\n  args: any[],\n  nodeUrl: string): Promise<starcoin_types.TransactionPayloadVariantScriptFunction> {\n  const tyArgs = encodeStructTypeTags(typeArgs)\n\n  const provider = new JsonRpcProvider(nodeUrl);\n  const { args: argsType } = await provider.send(\n    'contract.resolve_function',\n    [functionId]\n  );\n  // Remove the first Signer type\n  if (argsType[0] && argsType[0].type_tag === 'Signer') {\n    argsType.shift();\n  }\n\n  const argsBytes = encodeScriptFunctionArgs(argsType, args)\n\n  return encodeScriptFunction(functionId, tyArgs, argsBytes);\n}\n",
    "/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable no-bitwise */\n\nimport { arrayify, hexlify } from '@ethersproject/bytes';\nimport { cloneDeep } from 'lodash';\nimport { privateKeyToPublicKey } from \"../encoding\";\nimport { uint8 } from '../lib/runtime/serde/types';\nimport { getSignatureHex } from \"./tx\";\nimport {\n  MultiEd25519KeyShard,\n  MultiEd25519Signature,\n  MultiEd25519SignatureShard,\n  Ed25519Signature,\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  RawUserTransaction,\n} from \"../lib/runtime/starcoin_types\";\n\n\n/**\n * simillar to this command in the starcoin console:\n * starcoin% account import-multisig --pubkey <PUBLIC_KEY> --pubkey <PUBLIC_KEY> --prikey <PRIVATE_KEY> -t 2\n *\n * @param originPublicKeys  \n * @param originPrivateKeys\n * @param thresHold\n * @returns \n */\nexport async function generateMultiEd25519KeyShard(originPublicKeys: Array<string>, originPrivateKeys: Array<string>, thresHold: number): Promise<MultiEd25519KeyShard> {\n  if (originPrivateKeys.length === 0) {\n    throw new Error('require at least one private key');\n  }\n\n  const publicKeys = cloneDeep(originPublicKeys)\n  const pubPrivMap = {}\n\n  // 1. merge privateKeys' publicKey into publicKeys\n  // 2. generate pub->priv map\n  await Promise.all(\n    originPrivateKeys.map((priv) => {\n      return privateKeyToPublicKey(priv).then((pub) => {\n        publicKeys.push(pub);\n        pubPrivMap[pub] = priv;\n        return pub;\n      }).catch((error) => {\n        throw new Error(`invalid private key: ${ error }`)\n      })\n    })\n  )\n\n  // 3. sort all public keys by its bytes in asc order to make sure same public key set always generate same auth key.\n  publicKeys.sort((a, b) => {\n    return a > b ? 1 : -1\n  })\n\n  // 4. remove repeat public keys, if use add repeat public_key or private key.\n  const uniquePublicKeys = publicKeys.filter((v, i, a) => a.indexOf(v) === i)\n\n  // 5. generate pos_verified_private_keys\n  const pos_verified_private_keys = {};\n  await Promise.all(\n    originPrivateKeys.map((priv) => {\n      return privateKeyToPublicKey(priv).then((pub) => {\n        const idx = uniquePublicKeys.indexOf(pub)\n        if (idx > -1) {\n          pos_verified_private_keys[idx] = new Ed25519PrivateKey(arrayify(priv))\n        }\n        return pub;\n      }).catch((error) => {\n        throw new Error(`invalid private key: ${ error }`)\n      })\n    })\n  )\n\n  const public_keys = uniquePublicKeys.map((pub) => new Ed25519PublicKey(arrayify(pub)))\n  const shard = new MultiEd25519KeyShard(public_keys, thresHold, pos_verified_private_keys)\n  return Promise.resolve(shard);\n}\n\nexport async function generateMultiEd25519Signature(multiEd25519KeyShard: MultiEd25519KeyShard, rawUserTransaction: RawUserTransaction): Promise<MultiEd25519Signature> {\n  const signatures = await Promise.all(\n    Object.keys(multiEd25519KeyShard.private_keys).map((k) => {\n      const privateKey = hexlify(multiEd25519KeyShard.private_keys[k].value)\n      return getSignatureHex(rawUserTransaction, privateKey).then((signatureHex) => {\n        const signature = new Ed25519Signature(arrayify(signatureHex))\n        const pos = Number.parseInt(k, 10)\n        return [signature, pos] as [Ed25519Signature, uint8]\n      }).catch((error) => {\n        throw new Error(`invalid private key: ${ error }`)\n      })\n    })\n  )\n  console.log({ signatures })\n  const multiEd25519Signature = MultiEd25519Signature.build(signatures)\n  console.log({ multiEd25519Signature })\n  return Promise.resolve(multiEd25519Signature)\n}\n\nexport async function generateMultiEd25519SignatureShard(multiEd25519KeyShard: MultiEd25519KeyShard, rawUserTransaction: RawUserTransaction): Promise<MultiEd25519SignatureShard> {\n  const multiEd25519Signature = await generateMultiEd25519Signature(multiEd25519KeyShard, rawUserTransaction)\n  console.log({ multiEd25519Signature })\n  const multiEd25519SignatureShard = new MultiEd25519SignatureShard(multiEd25519Signature, multiEd25519KeyShard.threshold)\n  return Promise.resolve(multiEd25519SignatureShard)\n}",
    "import { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { JsonRpcProvider } from './jsonrpc-provider';\nimport { Networkish } from '../networks';\nimport { version } from '../version';\n\nconst logger = new Logger(version);\n\n// Exported Types\nexport type ExternalProvider = {\n    isStarMask?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet NextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend): JsonRpcFetchFunc {\n    return function (method: string, params: Array<any>): Promise<any> {\n\n        NextId += 1;\n        const request = {\n            method,\n            params,\n            id: (NextId),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            sendFunc(request, function (error, result) {\n                if (error) {\n                    return reject(error);\n                }\n\n                if (result.error) {\n                    const error = new Error(result.error.message);\n                    (<any>error).code = result.error.code;\n                    (<any>error).data = result.error.data;\n                    return reject(error);\n                }\n\n                resolve(result.result);\n            });\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        logger.checkNew(new.target, Web3Provider);\n\n        if (provider === undefined) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc;\n        let subprovider: ExternalProvider;\n\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isStarMask) {\n                path = \"starmask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n",
    "// import { setInterval } from 'timers';\n\nimport { Logger } from '@ethersproject/logger';\nimport { defineReadOnly } from '@ethersproject/properties';\nimport WebSocket from 'ws';\nimport { Network, Networkish } from '../networks';\nimport { version } from '../version';\nimport { CONSTANTS, Event } from './base-provider';\nimport { JsonRpcProvider } from './jsonrpc-provider';\n\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicats\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n  callback: (error: Error, result: any) => void;\n  payload: string;\n};\n\nexport type Subscription = {\n  tag: string;\n  processFunc: (payload: any) => void;\n};\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebsocketProvider extends JsonRpcProvider {\n  readonly _websocket: any;\n  readonly _requests: { [name: string]: InflightRequest };\n  readonly _detectNetwork: Promise<Network>;\n\n  // Maps event tag to subscription ID (we dedupe identical events)\n  readonly _subIds: { [tag: string]: Promise<string> };\n\n  // Maps Subscription ID to Subscription\n  readonly _subs: { [name: string]: Subscription };\n\n  _wsReady: boolean;\n\n  constructor(url?: string, network?: Networkish) {\n    // This will be added in the future; please open an issue to expedite\n    if (network === 'any') {\n      logger.throwError(\n        \"WebSocketProvider does not support 'any' network yet\",\n        Logger.errors.UNSUPPORTED_OPERATION,\n        {\n          operation: 'network:any',\n        }\n      );\n    }\n\n    super(url, network);\n    this._pollingInterval = -1;\n\n    this._wsReady = false;\n\n    defineReadOnly(this, '_websocket', new WebSocket(this.connection.url));\n    defineReadOnly(this, '_requests', {});\n    defineReadOnly(this, '_subs', {});\n    defineReadOnly(this, '_subIds', {});\n    defineReadOnly(this, '_detectNetwork', super.detectNetwork());\n\n    // Stall sending requests until the socket is open...\n    this._websocket.onopen = () => {\n      this._wsReady = true;\n      Object.keys(this._requests).forEach((id) => {\n        this._websocket.send(this._requests[id].payload);\n      });\n    };\n\n    this._websocket.onmessage = (messageEvent: { data: string }) => {\n      const data = messageEvent.data;\n      const result = JSON.parse(data);\n      if (result.id != null) {\n        const id = String(result.id);\n        const request = this._requests[id];\n        delete this._requests[id];\n\n        if (result.result !== undefined) {\n          request.callback(null, result.result);\n\n          this.emit('debug', {\n            action: 'response',\n            request: JSON.parse(request.payload),\n            response: result.result,\n            provider: this,\n          });\n        } else {\n          let error: Error;\n          if (result.error) {\n            error = new Error(result.error.message || 'unknown error');\n            defineReadOnly(<any>error, 'code', result.error.code || null);\n            defineReadOnly(<any>error, 'response', data);\n          } else {\n            error = new Error('unknown error');\n          }\n\n          request.callback(error, undefined);\n\n          this.emit('debug', {\n            action: 'response',\n            error,\n            request: JSON.parse(request.payload),\n            provider: this,\n          });\n        }\n      } else if (result.method === 'starcoin_subscription') {\n        // Subscription...\n        const sub = this._subs[result.params.subscription];\n        if (sub) {\n          sub.processFunc(result.params.result);\n        }\n      } else {\n        console.warn('this should not happen');\n      }\n    };\n\n    // This Provider does not actually poll, but we want to trigger\n    // poll events for things that depend on them (like stalling for\n    // block and transaction lookups)\n    const fauxPoll = setInterval(() => {\n      this.emit('poll');\n    }, 1000);\n    if (fauxPoll.unref) {\n      fauxPoll.unref();\n    }\n  }\n\n  detectNetwork(): Promise<Network> {\n    return this._detectNetwork;\n  }\n\n  get pollingInterval(): number {\n    return 0;\n  }\n\n  set pollingInterval(value: number) {\n    logger.throwError(\n      'cannot set polling interval on WebSocketProvider',\n      Logger.errors.UNSUPPORTED_OPERATION,\n      {\n        operation: 'setPollingInterval',\n      }\n    );\n  }\n\n  async poll(): Promise<void> {\n    return null;\n  }\n\n  set polling(value: boolean) {\n    if (!value) {\n      return;\n    }\n\n    logger.throwError(\n      'cannot set polling on WebSocketProvider',\n      Logger.errors.UNSUPPORTED_OPERATION,\n      {\n        operation: 'setPolling',\n      }\n    );\n  }\n\n  send(method: string, params?: Array<any>): Promise<any> {\n    const rid = NextId++;\n\n    return new Promise((resolve, reject) => {\n      function callback(error: Error, result: any) {\n        if (error) {\n          return reject(error);\n        }\n        return resolve(result);\n      }\n\n      const payload = JSON.stringify({\n        method: method,\n        params: params,\n        id: rid,\n        jsonrpc: '2.0',\n      });\n\n      this.emit('debug', {\n        action: 'request',\n        request: JSON.parse(payload),\n        provider: this,\n      });\n\n      this._requests[String(rid)] = { callback, payload };\n\n      if (this._wsReady) {\n        this._websocket.send(payload);\n      }\n    });\n  }\n\n  static defaultUrl(): string {\n    return 'ws://localhost:9870';\n  }\n\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then((param) => {\n        return this.send('starcoin_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  _startEvent(event: Event): void {\n    switch (event.type) {\n      case CONSTANTS.block:\n        this._subscribe(\n          CONSTANTS.block,\n          [{ type_name: 'newHeads' }],\n          (result: any) => {\n            // FIXME\n            const blockNumber = this.formatter.u64(\n              result.header.number\n            ) as number;\n            // const blockNumber = BigNumber.from(result.header.number).toNumber();\n            this._emitted.block = blockNumber;\n            this.emit(CONSTANTS.block, blockNumber);\n          }\n        );\n        break;\n\n      case CONSTANTS.pending:\n        this._subscribe(\n          CONSTANTS.pending,\n          [{ type_name: 'newPendingTransactions' }],\n          (result: any) => {\n            this.emit(CONSTANTS.pending, result);\n          }\n        );\n        break;\n\n      case CONSTANTS.filter:\n        this._subscribe(\n          event.tag,\n          [{ type_name: 'events' }, event.filter],\n          (result: any) => {\n            this.emit(event.filter, this.formatter.transactionEvent(result));\n          }\n        );\n        break;\n\n      case CONSTANTS.tx: {\n        const emitTxnInfo = (event: Event) => {\n          const hash = event.hash;\n          this.getTransactionInfo(hash).then((txnInfo) => {\n            if (!txnInfo) {\n              return;\n            }\n            this.emit(hash, txnInfo);\n          });\n        };\n\n        // In case it is already mined\n        emitTxnInfo(event);\n\n        // To keep things simple, we start up a single newHeads subscription\n        // to keep an eye out for transactions we are watching for.\n        // Starting a subscription for an event (i.e. \"tx\") that is already\n        // running is (basically) a nop.\n        this._subscribe(\n          CONSTANTS.tx,\n          [{ type_name: 'newHeads' }],\n          (result: any) => {\n            this._events\n              .filter((e) => e.type === CONSTANTS.tx)\n              .forEach(emitTxnInfo);\n          }\n        );\n        break;\n      }\n\n      // Nothing is needed\n      case 'debug':\n      case 'poll':\n      case 'willPoll':\n      case 'didPoll':\n      case 'error':\n        break;\n\n      default:\n        console.log('unhandled:', event);\n        break;\n    }\n  }\n\n  _stopEvent(event: Event): void {\n    let tag = event.tag;\n\n    if (event.type === CONSTANTS.tx) {\n      // There are remaining transaction event listeners\n      if (this._events.filter((e) => e.type === CONSTANTS.tx).length) {\n        return;\n      }\n      tag = CONSTANTS.tx;\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    subId.then((subId) => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      this.send('starcoin_unsubscribe', [subId]);\n    });\n  }\n\n  async destroy(): Promise<void> {\n    // Wait until we have connected before trying to disconnect\n    if (this._websocket.readyState === WebSocket.CONNECTING) {\n      await new Promise((resolve) => {\n        this._websocket.onopen = function () {\n          resolve(true);\n        };\n\n        this._websocket.onerror = function () {\n          resolve(false);\n        };\n      });\n    }\n\n    // Hangup\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n    this._websocket.close(1000);\n  }\n}\n",
    "\nimport { Serializer } from '../serde/serializer';\nimport { Deserializer } from '../serde/deserializer';\nimport { Optional, Seq, Tuple, ListTuple, unit, bool, int8, int16, int32, int64, int128, uint8, uint16, uint32, uint64, uint128, float32, float64, char, str, bytes} from '../serde/types';\n\nexport class AcceptTokenEvent {\n\nconstructor (public token_code: TokenCode) {\n}\n\npublic serialize(serializer: Serializer): void {\n  this.token_code.serialize(serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): AcceptTokenEvent {\n  const token_code = TokenCode.deserialize(deserializer);\n  return new AcceptTokenEvent(token_code);\n}\n\n}\nexport class AccountAddress {\n\nconstructor (public value: ListTuple<[uint8]>) {\n}\n\npublic serialize(serializer: Serializer): void {\n  Helpers.serializeArray16U8Array(this.value, serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): AccountAddress {\n  const value = Helpers.deserializeArray16U8Array(deserializer);\n  return new AccountAddress(value);\n}\n\n}\nexport class BlockRewardEvent {\n\nconstructor (public block_number: uint64, public block_reward: uint128, public gas_fees: uint128, public miner: AccountAddress) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU64(this.block_number);\n  serializer.serializeU128(this.block_reward);\n  serializer.serializeU128(this.gas_fees);\n  this.miner.serialize(serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): BlockRewardEvent {\n  const block_number = deserializer.deserializeU64();\n  const block_reward = deserializer.deserializeU128();\n  const gas_fees = deserializer.deserializeU128();\n  const miner = AccountAddress.deserialize(deserializer);\n  return new BlockRewardEvent(block_number,block_reward,gas_fees,miner);\n}\n\n}\nexport class BurnEvent {\n\nconstructor (public amount: uint128, public token_code: TokenCode) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU128(this.amount);\n  this.token_code.serialize(serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): BurnEvent {\n  const amount = deserializer.deserializeU128();\n  const token_code = TokenCode.deserialize(deserializer);\n  return new BurnEvent(amount,token_code);\n}\n\n}\nexport class DepositEvent {\n\nconstructor (public amount: uint128, public token_code: TokenCode, public metadata: Seq<uint8>) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU128(this.amount);\n  this.token_code.serialize(serializer);\n  Helpers.serializeVectorU8(this.metadata, serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): DepositEvent {\n  const amount = deserializer.deserializeU128();\n  const token_code = TokenCode.deserialize(deserializer);\n  const metadata = Helpers.deserializeVectorU8(deserializer);\n  return new DepositEvent(amount,token_code,metadata);\n}\n\n}\nexport class MintEvent {\n\nconstructor (public amount: uint128, public token_code: TokenCode) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU128(this.amount);\n  this.token_code.serialize(serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): MintEvent {\n  const amount = deserializer.deserializeU128();\n  const token_code = TokenCode.deserialize(deserializer);\n  return new MintEvent(amount,token_code);\n}\n\n}\nexport class NewBlockEvent {\n\nconstructor (public number: uint64, public author: AccountAddress, public timestamp: uint64, public uncles: uint64) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU64(this.number);\n  this.author.serialize(serializer);\n  serializer.serializeU64(this.timestamp);\n  serializer.serializeU64(this.uncles);\n}\n\nstatic deserialize(deserializer: Deserializer): NewBlockEvent {\n  const number = deserializer.deserializeU64();\n  const author = AccountAddress.deserialize(deserializer);\n  const timestamp = deserializer.deserializeU64();\n  const uncles = deserializer.deserializeU64();\n  return new NewBlockEvent(number,author,timestamp,uncles);\n}\n\n}\nexport class ProposalCreatedEvent {\n\nconstructor (public proposal_id: uint64, public proposer: AccountAddress) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU64(this.proposal_id);\n  this.proposer.serialize(serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): ProposalCreatedEvent {\n  const proposal_id = deserializer.deserializeU64();\n  const proposer = AccountAddress.deserialize(deserializer);\n  return new ProposalCreatedEvent(proposal_id,proposer);\n}\n\n}\nexport class TokenCode {\n\nconstructor (public address: AccountAddress, public module: str, public name: str) {\n}\n\npublic serialize(serializer: Serializer): void {\n  this.address.serialize(serializer);\n  serializer.serializeStr(this.module);\n  serializer.serializeStr(this.name);\n}\n\nstatic deserialize(deserializer: Deserializer): TokenCode {\n  const address = AccountAddress.deserialize(deserializer);\n  const module = deserializer.deserializeStr();\n  const name = deserializer.deserializeStr();\n  return new TokenCode(address,module,name);\n}\n\n}\nexport class VoteChangedEvent {\n\nconstructor (public proposal_id: uint64, public proposer: AccountAddress, public voter: AccountAddress, public agree: bool, public vote: uint128) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU64(this.proposal_id);\n  this.proposer.serialize(serializer);\n  this.voter.serialize(serializer);\n  serializer.serializeBool(this.agree);\n  serializer.serializeU128(this.vote);\n}\n\nstatic deserialize(deserializer: Deserializer): VoteChangedEvent {\n  const proposal_id = deserializer.deserializeU64();\n  const proposer = AccountAddress.deserialize(deserializer);\n  const voter = AccountAddress.deserialize(deserializer);\n  const agree = deserializer.deserializeBool();\n  const vote = deserializer.deserializeU128();\n  return new VoteChangedEvent(proposal_id,proposer,voter,agree,vote);\n}\n\n}\nexport class WithdrawEvent {\n\nconstructor (public amount: uint128, public token_code: TokenCode, public metadata: Seq<uint8>) {\n}\n\npublic serialize(serializer: Serializer): void {\n  serializer.serializeU128(this.amount);\n  this.token_code.serialize(serializer);\n  Helpers.serializeVectorU8(this.metadata, serializer);\n}\n\nstatic deserialize(deserializer: Deserializer): WithdrawEvent {\n  const amount = deserializer.deserializeU128();\n  const token_code = TokenCode.deserialize(deserializer);\n  const metadata = Helpers.deserializeVectorU8(deserializer);\n  return new WithdrawEvent(amount,token_code,metadata);\n}\n\n}\nexport class Helpers {\n  static serializeArray16U8Array(value: ListTuple<[uint8]>, serializer: Serializer): void {\n    value.forEach((item) =>{\n        serializer.serializeU8(item[0]);\n    });\n  }\n\n  static deserializeArray16U8Array(deserializer: Deserializer): ListTuple<[uint8]> {\n    const list: ListTuple<[uint8]> = [];\n    for (let i = 0; i < 16; i++) {\n        list.push([deserializer.deserializeU8()]);\n    }\n    return list;\n  }\n\n  static serializeVectorU8(value: Seq<uint8>, serializer: Serializer): void {\n    serializer.serializeLen(value.length);\n    value.forEach((item: uint8) => {\n        serializer.serializeU8(item);\n    });\n  }\n\n  static deserializeVectorU8(deserializer: Deserializer): Seq<uint8> {\n    const length = deserializer.deserializeLen();\n    const list: Seq<uint8> = [];\n    for (let i = 0; i < length; i++) {\n        list.push(deserializer.deserializeU8());\n    }\n    return list;\n  }\n\n}\n\n",
    "import { readBigUInt64LE } from \"read-bigint\";\nimport { arrayify, BytesLike } from '@ethersproject/bytes';\nimport {\n  AccountAddress,\n  AcceptTokenEvent,\n  BlockRewardEvent,\n  BurnEvent,\n  DepositEvent,\n  MintEvent,\n  NewBlockEvent,\n  ProposalCreatedEvent,\n  TokenCode,\n  VoteChangedEvent,\n  WithdrawEvent,\n} from '../types';\nimport { addressFromSCS, bcsDecode } from '../encoding';\nimport { toHexString } from '../utils/hex';\nimport { uint128, uint8 } from '../lib/runtime/serde';\nimport * as onchain_events from '../lib/runtime/onchain_events';\n\nconst ACCOUNT_ADDRESS_LENGTH = 16;\nconst EVENT_KEY_LENGTH = ACCOUNT_ADDRESS_LENGTH + 8;\n\ndeclare module '../lib/runtime/onchain_events' {\n  interface TokenCode {\n    toJS(): any;\n  }\n  interface AcceptTokenEvent {\n    toJS(): any;\n  }\n  interface BlockRewardEvent {\n    toJS(): any;\n  }\n  interface BurnEvent {\n    toJS(): any;\n  }\n  interface MintEvent {\n    toJS(): any;\n  }\n  interface DepositEvent {\n    toJS(): any;\n  }\n  interface WithdrawEvent {\n    toJS(): any;\n  }\n  interface NewBlockEvent {\n    toJS(): any;\n  }\n  interface VoteChangedEvent {\n    toJS(): any;\n  }\n  interface ProposalCreatedEvent {\n    toJS(): any;\n  }\n}\n\nonchain_events.TokenCode.prototype.toJS = function (): TokenCode {\n  return {\n    address: addressFromSCS(this.address),\n    module: this.module,\n    name: this.name,\n  };\n};\n\nonchain_events.DepositEvent.prototype.toJS = function (): {\n  amount: uint128;\n  token_code: TokenCode;\n  metadata: uint8[];\n} {\n  return {\n    amount: this.amount,\n    metadata: this.metadata,\n    token_code: this.token_code.toJS(),\n  };\n};\n\nonchain_events.AcceptTokenEvent.prototype.toJS = function (): AcceptTokenEvent {\n  return { token_code: this.token_code.toJS() };\n};\n\nonchain_events.BlockRewardEvent.prototype.toJS = function (): BlockRewardEvent {\n  return {\n    block_number: this.block_number,\n    block_reward: this.block_reward,\n    gas_fees: this.gas_fees,\n    miner: addressFromSCS(this.miner),\n  };\n};\n\nonchain_events.BurnEvent.prototype.toJS = function (): BurnEvent {\n  return {\n    amount: this.amount,\n    token_code: this.token_code.toJS(),\n  };\n};\n\nonchain_events.MintEvent.prototype.toJS = function (): MintEvent {\n  return {\n    amount: this.amount,\n    token_code: this.token_code.toJS(),\n  };\n};\nonchain_events.NewBlockEvent.prototype.toJS = function (): NewBlockEvent {\n  return {\n    number: this.number,\n    author: addressFromSCS(this.author),\n    timestamp: this.timestamp,\n    uncles: this.uncles,\n  };\n};\nonchain_events.ProposalCreatedEvent.prototype.toJS = function (): ProposalCreatedEvent {\n  return {\n    proposal_id: this.proposal_id,\n    proposer: addressFromSCS(this.proposer),\n  };\n};\n\nonchain_events.VoteChangedEvent.prototype.toJS = function (): VoteChangedEvent {\n  return {\n    agree: this.agree,\n    vote: this.vote,\n    voter: addressFromSCS(this.voter),\n    proposal_id: this.proposal_id,\n    proposer: addressFromSCS(this.proposer),\n  };\n};\n\nonchain_events.WithdrawEvent.prototype.toJS = function (): WithdrawEvent {\n  return {\n    amount: this.amount,\n    metadata: this.metadata,\n    token_code: this.token_code.toJS(),\n  };\n};\nonchain_events.DepositEvent.prototype.toJS = function (): DepositEvent {\n  return {\n    amount: this.amount,\n    metadata: this.metadata,\n    token_code: this.token_code.toJS(),\n  };\n};\n\n\n/// Decode a hex view or raw bytes of event key into parts.\n/// EventKey is constructed by `Salt+AccountAddress`.\nexport function decodeEventKey(\n  eventKey: BytesLike\n): { address: AccountAddress; salt: BigInt } {\n  const bytes = arrayify(eventKey);\n  if (bytes.byteLength !== EVENT_KEY_LENGTH) {\n    throw new Error(\n      `invalid eventkey data, expect byte length to be ${EVENT_KEY_LENGTH}, actual: ${bytes.byteLength}`\n    );\n  }\n  const saltBytes = bytes.slice(0, EVENT_KEY_LENGTH - ACCOUNT_ADDRESS_LENGTH);\n  const buff = Buffer.from(saltBytes);\n  // const salt = buff.readBigUInt64LE();\n  const salt = readBigUInt64LE(buff);\n  const addressBytes = bytes.slice(EVENT_KEY_LENGTH - ACCOUNT_ADDRESS_LENGTH);\n  const address = toHexString(addressBytes);\n  return { address, salt };\n}\n\nexport function decodeEventData(eventName: string, eventData: string): any {\n  const eventType = onchain_events[eventName];\n  const d = bcsDecode(\n    eventType,\n    eventData\n  );\n  return d;\n}"
  ],
  "names": [
    "accountType",
    "SINGLE",
    "MULTI",
    "formatStructTag",
    "structTag",
    "s",
    "address",
    "module",
    "name",
    "type_params",
    "length",
    "concat",
    "formatTypeTag",
    "slice",
    "t",
    "typeTag",
    "toLowerCase",
    "undefined",
    "Vector",
    "Struct",
    "TransactionVMStatus_Executed",
    "TransactionVMStatus_OutOfGas",
    "TransactionVMStatus_MiscellaneousError",
    "formatFunctionId",
    "functionId",
    "functionName",
    "parseFunctionId",
    "parts",
    "split",
    "Error",
    "BinaryDeserializer",
    "data",
    "this",
    "buffer",
    "ArrayBuffer",
    "Uint8Array",
    "set",
    "offset",
    "read",
    "bytes",
    "deserializeStr",
    "value",
    "deserializeBytes",
    "textDecoder",
    "decode",
    "len",
    "deserializeLen",
    "deserializeBool",
    "deserializeUnit",
    "deserializeU8",
    "DataView",
    "getUint8",
    "deserializeU16",
    "getUint16",
    "deserializeU32",
    "getUint32",
    "deserializeU64",
    "low",
    "high",
    "BigInt",
    "BIG_32",
    "deserializeU128",
    "BIG_64",
    "deserializeI8",
    "getInt8",
    "deserializeI16",
    "getInt16",
    "deserializeI32",
    "getInt32",
    "deserializeI64",
    "deserializeI128",
    "deserializeOptionTag",
    "getBufferOffset",
    "deserializeChar",
    "deserializeF32",
    "getFloat32",
    "deserializeF64",
    "getFloat64",
    "TextDecoder",
    "BcsDeserializer",
    "deserializeUleb128AsU32",
    "shift",
    "x",
    "digit",
    "MAX_UINT_32",
    "deserializeVariantIndex",
    "checkThatKeySlicesAreIncreasing",
    "key1",
    "key2",
    "Math",
    "BinarySerializer",
    "ensureBufferWillHandleSize",
    "byteLength",
    "newBuffer",
    "serialize",
    "values",
    "serializeStr",
    "serializeBytes",
    "textEncoder",
    "encode",
    "serializeLen",
    "serializeBool",
    "serializeUnit",
    "serializeWithFunction",
    "fn",
    "bytesLength",
    "dv",
    "apply",
    "serializeU8",
    "serializeU16",
    "prototype",
    "setUint16",
    "serializeU32",
    "setUint32",
    "serializeU64",
    "BIG_32Fs",
    "Number",
    "serializeU128",
    "BIG_64Fs",
    "serializeI8",
    "setInt8",
    "serializeI16",
    "setInt16",
    "serializeI32",
    "setInt32",
    "serializeI64",
    "serializeI128",
    "serializeOptionTag",
    "getBytes",
    "serializeChar",
    "serializeF32",
    "setFloat32",
    "serializeF64",
    "setFloat64",
    "TextEncoder",
    "BcsSerializer",
    "serializeU32AsUleb128",
    "valueArray",
    "push",
    "serializeVariantIndex",
    "sortMapEntries",
    "offsets",
    "dec2bin",
    "dec",
    "toString",
    "bin2dec",
    "bin",
    "parseInt",
    "dec2uint8array",
    "n",
    "arr",
    "match",
    "from",
    "map",
    "str",
    "uint8array2dec",
    "bitmap",
    "binArr",
    "forEach",
    "join",
    "setBit",
    "idx",
    "isSetBit",
    "AccessPath",
    "field0",
    "field1",
    "serializer",
    "deserialize",
    "deserializer",
    "AccountAddress",
    "DataPath",
    "Helpers",
    "serializeArray16U8Array",
    "deserializeArray16U8Array",
    "AccountResource",
    "authentication_key",
    "withdrawal_capability",
    "key_rotation_capability",
    "withdraw_events",
    "deposit_events",
    "accept_token_events",
    "sequence_number",
    "serializeVectorU8",
    "serializeOptionWithdrawCapabilityResource",
    "serializeOptionKeyRotationCapabilityResource",
    "deserializeVectorU8",
    "deserializeOptionWithdrawCapabilityResource",
    "deserializeOptionKeyRotationCapabilityResource",
    "EventHandle",
    "ArgumentABI",
    "type_tag",
    "TypeTag",
    "AuthenticationKey",
    "BlockMetadata",
    "parent_hash",
    "timestamp",
    "author",
    "author_auth_key",
    "uncles",
    "number",
    "chain_id",
    "parent_gas_used",
    "serializeOptionAuthenticationKey",
    "HashValue",
    "deserializeOptionAuthenticationKey",
    "ChainId",
    "id",
    "ContractEvent",
    "index",
    "ContractEventVariantV0",
    "load",
    "_this",
    "ContractEventV0",
    "key",
    "event_data",
    "EventKey",
    "DataPathVariantCode",
    "DataPathVariantResource",
    "_this2",
    "Identifier",
    "_this3",
    "StructTag",
    "DataType",
    "DataTypeVariantCODE",
    "DataTypeVariantRESOURCE",
    "Ed25519PrivateKey",
    "Ed25519PublicKey",
    "Ed25519Signature",
    "count",
    "KeyRotationCapabilityResource",
    "account_address",
    "Module",
    "code",
    "ModuleId",
    "MultiEd25519PrivateKey",
    "MultiEd25519PublicKey",
    "public_keys",
    "threshold",
    "num_of_public_keys",
    "i",
    "start",
    "arrPub",
    "pub",
    "arrThreshold",
    "MultiEd25519Signature",
    "signatures",
    "build",
    "origin_signatures",
    "num_of_sigs",
    "sorted_signatures",
    "sort",
    "a",
    "b",
    "sigs",
    "k",
    "v",
    "console",
    "log",
    "CryptoMaterialError",
    "arrSignatures",
    "signature",
    "arrBitmap",
    "MultiEd25519SignatureShard",
    "result",
    "bitmap_index",
    "merge",
    "shards",
    "shard",
    "is_enough",
    "MultiEd25519KeyShard",
    "private_keys",
    "num_of_private_keys",
    "Object",
    "keys",
    "pos",
    "_this4",
    "publicKeysLen",
    "privateKeysLen",
    "privateKey",
    "publicKey",
    "privateKeys",
    "arrHead",
    "arrPriv",
    "priv",
    "isEmpty",
    "Package",
    "package_address",
    "modules",
    "init_script",
    "serializeVectorModule",
    "serializeOptionScriptFunction",
    "deserializeVectorModule",
    "deserializeOptionScriptFunction",
    "RawUserTransaction",
    "sender",
    "payload",
    "max_gas_amount",
    "gas_unit_price",
    "gas_token_code",
    "expiration_timestamp_secs",
    "TransactionPayload",
    "Script",
    "ty_args",
    "args",
    "serializeVectorTypeTag",
    "serializeVectorBytes",
    "deserializeVectorTypeTag",
    "deserializeVectorBytes",
    "ScriptABI",
    "ScriptABIVariantTransactionScript",
    "ScriptABIVariantScriptFunction",
    "_this5",
    "TransactionScriptABI",
    "_this6",
    "ScriptFunctionABI",
    "ScriptFunction",
    "func",
    "module_name",
    "doc",
    "serializeVectorTypeArgumentAbi",
    "serializeVectorArgumentAbi",
    "deserializeVectorTypeArgumentAbi",
    "deserializeVectorArgumentAbi",
    "SignedUserTransaction",
    "raw_txn",
    "authenticator",
    "TransactionAuthenticator",
    "ed25519",
    "public_key",
    "TransactionAuthenticatorVariantEd25519",
    "multi_ed25519",
    "TransactionAuthenticatorVariantMultiEd25519",
    "Transaction",
    "TransactionVariantUserTransaction",
    "TransactionVariantBlockMetadata",
    "_this7",
    "_this8",
    "TransactionArgument",
    "TransactionArgumentVariantU8",
    "TransactionArgumentVariantU64",
    "TransactionArgumentVariantU128",
    "TransactionArgumentVariantAddress",
    "TransactionArgumentVariantU8Vector",
    "TransactionArgumentVariantBool",
    "_this9",
    "_this10",
    "_this11",
    "_this12",
    "_this13",
    "_this14",
    "_this15",
    "_this16",
    "TransactionPayloadVariantScript",
    "TransactionPayloadVariantPackage",
    "TransactionPayloadVariantScriptFunction",
    "_this17",
    "_this18",
    "_this19",
    "TypeArgumentABI",
    "TypeTagVariantBool",
    "TypeTagVariantU8",
    "TypeTagVariantU64",
    "TypeTagVariantU128",
    "TypeTagVariantAddress",
    "TypeTagVariantSigner",
    "TypeTagVariantVector",
    "TypeTagVariantStruct",
    "_this20",
    "_this21",
    "WithdrawCapabilityResource",
    "WriteOp",
    "WriteOpVariantDeletion",
    "WriteOpVariantValue",
    "_this22",
    "WriteSet",
    "WriteSetMut",
    "write_set",
    "serializeVectorTuple2AccessPathWriteOp",
    "deserializeVectorTuple2AccessPathWriteOp",
    "item",
    "list",
    "serializeTuple2AccessPathWriteOp",
    "deserializeTuple2AccessPathWriteOp",
    "AuthKey",
    "hex",
    "Buffer",
    "ReceiptIdentifier",
    "accountAddress",
    "authKey",
    "se",
    "dataBuff",
    "words",
    "bech32",
    "toWords",
    "wordsPrefixVersion",
    "dataBytes",
    "fromWords",
    "accountAddressBytes",
    "LENGTH",
    "authKeyBytes",
    "SigningMessage",
    "message",
    "SignedMessage",
    "account",
    "require",
    "sha3_256",
    "DefaultHasher",
    "typename",
    "hasher",
    "create",
    "update",
    "salt",
    "arrayBuffer",
    "crypto_hash",
    "arrayify",
    "addHexPrefix",
    "get_salt",
    "createHash",
    "createUserTransactionHasher",
    "createRawUserTransactionHasher",
    "createSigningMessageHasher",
    "toHexString",
    "byteArray",
    "fromHexString",
    "padding",
    "startsWith",
    "substring",
    "padLeft",
    "buf",
    "chars",
    "sign",
    "Array",
    "privateKeyToPublicKey",
    "ed",
    "stripHexPrefix",
    "bcsDecode",
    "de",
    "bcsEncode",
    "decodeSignedUserTransaction",
    "scsData",
    "starcoin_types",
    "Ed25519",
    "hexlify",
    "auth",
    "MultiEd25519",
    "rawTxn",
    "transaction_hash",
    "addressFromSCS",
    "packageHexToTransactionPayload",
    "packageHex",
    "addressToSCS",
    "addr",
    "typeTagToSCS",
    "ty",
    "structTagToSCS",
    "structTagFromSCS",
    "bcs_data",
    "typeTagFromSCS",
    "TypeError",
    "publicKeyToAuthKey",
    "singleMulti",
    "hash",
    "publicKeyToAddress",
    "encodeReceiptIdentifier",
    "addressStr",
    "authKeyStr",
    "bcsTxnPayload",
    "script",
    "arg",
    "scriptFunction",
    "packagePayload",
    "m",
    "receiptIdentifier",
    "c",
    "charCodeAt",
    "one",
    "store",
    "st",
    "String",
    "fromCharCode",
    "abi",
    "bcs_to_json",
    "showAccount",
    "generatePrivateKey",
    "privateKeyBytes",
    "utils",
    "randomPrivateKey",
    "getMultiEd25519AccountPrivateKey",
    "getMultiEd25519AccountPublicKey",
    "multiEd25519PublicKey",
    "getMultiEd25519AccountAddress",
    "getMultiEd25519AccountReceiptIdentifier",
    "accountInfo",
    "end",
    "publicKeysLength",
    "privateKeysLength",
    "publicKeys",
    "publicKeyBytes",
    "given",
    "expected",
    "methodName",
    "host",
    "error",
    "JSON",
    "stringify",
    "ms",
    "Parser",
    "toks",
    "next_tok",
    "tok",
    "cur_idx",
    "peek",
    "consume_tok",
    "parse_comma_list",
    "parse_list_item",
    "end_token",
    "allow_trailing_comma",
    "parseTypeTag",
    "module_tok",
    "struct_tok",
    "struct_name",
    "tyArgs",
    "p",
    "nameToken",
    "Name",
    "nextToken",
    "character",
    "head",
    "includes",
    "hexadecimal",
    "r",
    "Address",
    "decimal",
    "num",
    "alphabetical",
    "suffix",
    "alphanumerical",
    "U8",
    "U64",
    "U128",
    "nextNumber",
    "Bytes",
    "whitespace",
    "WhiteSpace",
    "parse",
    "f",
    "nextTok",
    "tokenize",
    "filter",
    "parser",
    "res",
    "version",
    "logger",
    "Logger",
    "checkProperties",
    "object",
    "properties",
    "throwArgumentError",
    "generateSignedMessage",
    "signingMessage",
    "publicKeyHex",
    "signatureHex",
    "transactionAuthenticatorEd25519",
    "encodeTransactionAuthenticatorEd25519",
    "chainId",
    "signedMessageBytes",
    "signedMessageHex",
    "Promise",
    "resolve",
    "signMessage",
    "msg",
    "privateKeyHex",
    "msgBytes",
    "signingMessageBytes",
    "getEd25519SignMsgBytes",
    "signatureBytes",
    "ed25519PublicKey",
    "ed25519Signature",
    "tmp",
    "decodeSignedMessage",
    "signedMessage",
    "isSigned",
    "checkAccount",
    "STANDARD_NETWORKS",
    "test",
    "_defaultProvider",
    "stcDefaultProvider",
    "network",
    "providers",
    "options",
    "JsonRpcProvider",
    "jsonrpc",
    "renetwork",
    "dev",
    "barnard",
    "halley",
    "proxima",
    "main",
    "getNetwork",
    "standard",
    "defaultProvider",
    "Provider",
    "checkAbstract",
    "defineReadOnly",
    "getBalance",
    "token",
    "blockTag",
    "getResource",
    "resource",
    "getBalances",
    "getResources",
    "resources",
    "tokenBalances",
    "getSequenceNumber",
    "addListener",
    "eventName",
    "listener",
    "on",
    "removeListener",
    "off",
    "isProvider",
    "_isProvider",
    "formatMoveStruct",
    "reduce",
    "o",
    "formatMoveValue",
    "Bool",
    "Formatter",
    "bigint",
    "hexValue",
    "elem",
    "checkNew",
    "formats",
    "getDefaultFormats",
    "bind",
    "bigNumber",
    "u64",
    "u8",
    "u256",
    "rawTransaction",
    "signedUserTransaction",
    "rawUserTransaction",
    "transactionAuthenticator",
    "blockMetadata",
    "txnBlockInfo",
    "block_hash",
    "allowNull",
    "block_number",
    "transaction_index",
    "transaction",
    "block_metadata",
    "user_transaction",
    "blockBody",
    "Full",
    "arrayOf",
    "Hashes",
    "blockHeader",
    "txn_accumulator_root",
    "block_accumulator_root",
    "state_root",
    "gas_used",
    "difficulty",
    "nonce",
    "body_hash",
    "blockWithTransactions",
    "header",
    "check",
    "body",
    "block",
    "confirmations",
    "transactionInfo",
    "state_root_hash",
    "event_root_hash",
    "status",
    "transactionVmStatus",
    "txn_events",
    "transactionEvent",
    "type_tags",
    "event_key",
    "event_seq_number",
    "transactionOutput",
    "events",
    "transactionWriteAction",
    "shallowCopy",
    "transactions",
    "transactionResponse",
    "eventFilter",
    "from_block",
    "to_block",
    "event_keys",
    "limit",
    "moveValue",
    "moveStruct",
    "MoveAbort",
    "location",
    "abort_code",
    "ExecutionFailure",
    "Discard",
    "status_code",
    "BigNumber",
    "toNumber",
    "u128",
    "bn",
    "MAX_SAFE_INTEGER",
    "strict",
    "isHexString",
    "hexDataLength",
    "_block",
    "blockWithTxnHashes",
    "userTransactionData",
    "topics",
    "isArray",
    "format",
    "checkKey",
    "checkValue",
    "nullValue",
    "allowFalsish",
    "replaceValue",
    "array",
    "e",
    "serializeTopics",
    "eventKeys",
    "getEventTag",
    "indexOf",
    "getTime",
    "Date",
    "defaultFormatter",
    "CONSTANTS",
    "pending",
    "poll",
    "tx",
    "PollableEvents",
    "Event",
    "tag",
    "once",
    "pollable",
    "type",
    "comps",
    "RPC_ACTION",
    "getChainInfo",
    "getNodeInfo",
    "sendTransaction",
    "getBlock",
    "getTransactionByHash",
    "getTransactionInfo",
    "getEventsOfTransaction",
    "getEvents",
    "call",
    "callV2",
    "getCode",
    "getAccountState",
    "getGasPrice",
    "dryRun",
    "dryRunRaw",
    "nextPollId",
    "BaseProvider",
    "_events",
    "_emitted",
    "formatter",
    "getFormatter",
    "anyNetwork",
    "detectNetwork",
    "_networkPromise",
    "_ready",
    "knownNetwork",
    "emit",
    "_maxInternalBlockNumber",
    "_lastBlockNumber",
    "_pollingInterval",
    "_fastQueryDate",
    "_network",
    "throwError",
    "errors",
    "UNKNOWN_ERROR",
    "_getInternalBlockNumber",
    "maxAge",
    "reqTime",
    "checkInternalBlockNumber",
    "resolveProperties",
    "blockNumber",
    "perform",
    "then",
    "chainInfo",
    "err",
    "networkError",
    "_internalBlockNumber",
    "respTime",
    "_setFastBlockNumber",
    "internalBlockNumber",
    "pollId",
    "runners",
    "pollingInterval",
    "abs",
    "warn",
    "makeError",
    "NETWORK_ERROR",
    "event",
    "previousBlockNumber",
    "eventBlockNumber",
    "runner",
    "receipt",
    "getTransactionEvents",
    "logs",
    "all",
    "currentNetwork",
    "detectedNetwork",
    "_fastBlockNumber",
    "_fastBlockNumberPromise",
    "setTimeout",
    "_getFastBlockNumber",
    "now",
    "getBlockNumber",
    "waitForTransaction",
    "transactionHash",
    "timeout",
    "reject",
    "timer",
    "done",
    "handler",
    "clearTimeout",
    "TIMEOUT",
    "unref",
    "moduleId",
    "getModuleId",
    "params",
    "resource_struct_tag",
    "entries",
    "_wrapTransaction",
    "expectedHash",
    "returnedHash",
    "wait",
    "_this23",
    "CALL_EXCEPTION",
    "signedTransaction",
    "_this25",
    "hexTx",
    "_getFilter",
    "_this27",
    "_this26$formatter",
    "request",
    "_this29",
    "function_id",
    "rets",
    "_this31",
    "_this33",
    "resp",
    "rawUserTransactionHex",
    "_this35",
    "_getBlock",
    "blockHashOrBlockNumber",
    "includeTransactions",
    "_this37",
    "blockHash",
    "oncePoll",
    "_getBlockTag",
    "getTransaction",
    "_this39",
    "_this41",
    "_this43",
    "_this45",
    "_this47",
    "_startEvent",
    "polling",
    "_stopEvent",
    "_addEventListener",
    "stopped",
    "eventTag",
    "_this48",
    "listenerCount",
    "listeners",
    "removeAllListeners",
    "found",
    "_this49",
    "_this50",
    "_this51",
    "_poller",
    "setInterval",
    "_bootstrapPoll",
    "_this52",
    "clearInterval",
    "_this53",
    "allowedTransactionKeys",
    "Set",
    "forwardErrors",
    "INSUFFICIENT_FUNDS",
    "NONCE_EXPIRED",
    "REPLACEMENT_UNDERPRICED",
    "Signer",
    "checkProvider",
    "provider",
    "getAddress",
    "estimateGas",
    "checkTransaction",
    "txnOutput",
    "valueOf",
    "populateTransaction",
    "signTransaction",
    "signedTx",
    "getChainId",
    "has",
    "results",
    "UNPREDICTABLE_GAS_LIMIT",
    "operation",
    "UNSUPPORTED_OPERATION",
    "isSigner",
    "_isSigner",
    "errorGas",
    "checkError",
    "method",
    "SERVER_ERROR",
    "responseText",
    "getResult",
    "_constructorGuard",
    "JsonRpcSigner",
    "constructorGuard",
    "addressOrIndex",
    "connect",
    "_address",
    "send",
    "accounts",
    "_index",
    "sendUncheckedTransaction",
    "debug",
    "fromAddress",
    "constructor",
    "hexlifyTransaction",
    "expiredSecs",
    "addGasBufferMultiplier",
    "hexTxnData",
    "u8a",
    "isBytes",
    "messageArg",
    "unlock",
    "password",
    "gasLimit",
    "gasPrice",
    "to",
    "url",
    "networkOrReady",
    "getStatic",
    "freeze",
    "_nextId",
    "defaultUrl",
    "serverError",
    "getSigner",
    "getNowSeconds",
    "nodeInfo",
    "now_seconds",
    "action",
    "deepCopy",
    "fetchJson",
    "connection",
    "response",
    "prepareRequest",
    "NOT_IMPLEMENTED",
    "_BaseProvider",
    "_pendingFilter",
    "allowExtra",
    "allowed",
    "getSignedUserTransaction",
    "senderPrivateKey",
    "getSignatureHex",
    "generateSignedUserTransaction",
    "senderPublicKeyMissingPrefix",
    "signTxn",
    "hashSeedBytes",
    "rawUserTransactionBytes",
    "encodeScriptFunction",
    "funcId",
    "senderPublicKey",
    "transactionAuthenticatorVariantEd25519",
    "encodeStructTypeTags",
    "typeArgsString",
    "encodeStructTypeTag",
    "arr1",
    "replace",
    "param",
    "trim",
    "encodeScriptFunctionArgs",
    "argsType",
    "valueBytes",
    "sub",
    "serializeWithType",
    "generateMultiEd25519Signature",
    "multiEd25519KeyShard",
    "multiEd25519Signature",
    "multiEd25519SignatureShard",
    "originPublicKeys",
    "originPrivateKeys",
    "thresHold",
    "cloneDeep",
    "pubPrivMap",
    "uniquePublicKeys",
    "pos_verified_private_keys",
    "typeArgs",
    "nodeUrl",
    "argsBytes",
    "getSignedUserTransactionHex",
    "moduleAddress",
    "moduleCodes",
    "initScriptFunction",
    "packageData",
    "senderAddress",
    "maxGasAmount",
    "gasUnitPrice",
    "senderSequenceNumber",
    "expirationTimestampSecs",
    "NextId",
    "buildWeb3LegacyFetcher",
    "sendFunc",
    "Web3Provider",
    "path",
    "jsonRpcFetchFunc",
    "subprovider",
    "isStarMask",
    "sendAsync",
    "_wsReady",
    "WebSocket",
    "_websocket",
    "onopen",
    "_requests",
    "onmessage",
    "messageEvent",
    "callback",
    "_subs",
    "subscription",
    "processFunc",
    "fauxPoll",
    "_detectNetwork",
    "rid",
    "_subscribe",
    "subIdPromise",
    "_subIds",
    "subId",
    "type_name",
    "emitTxnInfo",
    "txnInfo",
    "destroy",
    "close",
    "readyState",
    "CONNECTING",
    "onerror",
    "AcceptTokenEvent",
    "token_code",
    "TokenCode",
    "BlockRewardEvent",
    "block_reward",
    "gas_fees",
    "miner",
    "BurnEvent",
    "amount",
    "DepositEvent",
    "metadata",
    "MintEvent",
    "NewBlockEvent",
    "ProposalCreatedEvent",
    "proposal_id",
    "proposer",
    "VoteChangedEvent",
    "voter",
    "agree",
    "vote",
    "WithdrawEvent",
    "onchain_events",
    "toJS",
    "eventKey",
    "ACCOUNT_ADDRESS_LENGTH",
    "saltBytes",
    "EVENT_KEY_LENGTH",
    "buff",
    "readBigUInt64LE",
    "eventData"
  ],
  "mappings": "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"
}
