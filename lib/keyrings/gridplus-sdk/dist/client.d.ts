/// <reference types="node" />
/**
 * `Client` is a class-based interface for managing a Lattice device.
 */
export declare class Client {
    /** Is the Lattice paired with this Client. */
    isPaired: boolean;
    /** The time to wait for a response before cancelling. */
    timeout: number;
    /** The base of the remote url to which the SDK sends requests. */
    baseUrl: string;
    /** @internal The `baseUrl` plus the `deviceId`. Set in {@link connect} when it completes successfully.  */
    url?: string;
    /** `name` is a human readable string associated with this app on the Lattice */
    private name;
    private key;
    /**`privKey` is used to generate a keypair, which is used for maintaining an encrypted messaging channel with the target Lattice  */
    private privKey;
    private retryCount;
    private fwVersion?;
    private skipRetryOnWrongWallet;
    /** Temporary secret that is generated by the Lattice device */
    private _ephemeralPub;
    /** The ID of the connected Lattice */
    private deviceId;
    /** Information about the current wallet. Should be null unless we know a wallet is present */
    activeWallets: ActiveWallets;
    /** A wrapper function for handling retries and injecting the {@link Client} class  */
    private retryWrapper;
    /**
     * @param params - Parameters are passed as an object.
     */
    constructor({ baseUrl, name, privKey, stateData, timeout, retryCount, skipRetryOnWrongWallet, }: {
        /** The base URL of the signing server. */
        baseUrl?: string;
        /** The name of the client. */
        name?: string;
        /** The private key of the client.*/
        privKey?: Buffer | string;
        /** Number of times to retry a request if it fails. */
        retryCount?: number;
        /** The time to wait for a response before cancelling. */
        timeout?: number;
        /** User can pass in previous state data to rehydrate connected session */
        stateData?: string;
        /** If true we will not retry if we get a wrong wallet error code */
        skipRetryOnWrongWallet?: boolean;
    });
    /**
     * Get the shared secret, derived via ECDH from the local private key and the ephemeral public key
     * @internal
     * @returns Buffer
     */
    get sharedSecret(): Buffer;
    /** @internal */
    get ephemeralPub(): KeyPair;
    /** @internal */
    set ephemeralPub(ephemeralPub: KeyPair);
    /**
     * Attempt to contact a device based on its `deviceId`. The response should include an ephemeral
     * public key, which is used to pair with the device in a later request.
     * @category Lattice
     */
    connect(deviceId: string): Promise<any>;
    /**
     * If a pairing secret is provided, `pair` uses it to sign a hash of the public key, name, and
     * pairing secret. It then sends the name and signature to the device. If no pairing secret is
     * provided, `pair` sends a zero-length name buffer to the device.
     * @category Lattice
     */
    pair(pairingSecret: string): Promise<any>;
    /**
     * Takes a starting path and a number to get the addresses associated with the active wallet.
     * @category Lattice
     */
    getAddresses({ startPath, n, flag, }: GetAddressesRequestParams): Promise<Buffer[] | string[]>;
    /**
     * Builds and sends a request for signing to the Lattice.
     * @category Lattice
     */
    sign({ data, currency, cachedData, nextCode, }: SignRequestParams): Promise<SignData>;
    /**
     * Fetch the active wallet in the Lattice.
     */
    fetchActiveWallet(): Promise<ActiveWallets>;
    /**
     * Takes in a set of key-value records and sends a request to add them to the Lattice.
     * @category Lattice
     */
    addKvRecords({ type, records, caseSensitive, }: AddKvRecordsRequestParams): Promise<Buffer>;
    /**
     * Fetches a list of key-value records from the Lattice.
     * @category Lattice
     */
    getKvRecords({ type, n, start, }: GetKvRecordsRequestParams): Promise<GetKvRecordsData>;
    /**
     * Takes in an array of ids and sends a request to remove them from the Lattice.
     * @category Lattice
     */
    removeKvRecords({ type, ids, }: RemoveKvRecordsRequestParams): Promise<Buffer>;
    /** Get the active wallet */
    getActiveWallet(): Wallet;
    /** Check if the user has an active wallet */
    hasActiveWallet(): boolean;
    /**
     * Reset the active wallets to empty values.
     * @category Device Response
     * @internal
     */
    resetActiveWallets(): void;
    /**
     * Get a JSON string containing state data that can be used to rehydrate a session. Pass the
     * contents of this to the constructor as `stateData` to rehydrate.
     * @internal
     */
    getStateData(): string;
    /**
     * Returns the firmware version constants for the given firmware version.
     * @internal
     */
    getFwConstants(): FirmwareConstants;
    /**
     * `getFwVersion` gets the firmware version of the paired device.
     * @internal
     */
    getFwVersion(): {
        fix: number;
        minor: number;
        major: number;
    };
    /**
     * `getAppName` returns the name of the application to which this device is currently paired.
     */
    getAppName(): string;
    /**
     * Return JSON-stringified version of state data. Can be used to rehydrate an SDK session without
     * reconnecting to the target Lattice.
     * @internal
     */
    private packStateData;
    /**
     * Unpack a JSON-stringified version of state data and apply it to state. This will allow us to
     * rehydrate an old session.
     * @internal
     */
    private unpackAndApplyStateData;
}
//# sourceMappingURL=client.d.ts.map